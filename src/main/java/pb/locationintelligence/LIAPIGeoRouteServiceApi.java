/**
 * Location Intelligence APIs
 * Incorporate our extensive geodata into everyday applications, business processes and workflows.
 *
 * OpenAPI spec version: 6.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package pb.locationintelligence;

import pb.ApiCallback;
import pb.ApiClient;
import pb.ApiException;
import pb.ApiResponse;
import pb.Configuration;
import pb.Pair;
import pb.ProgressRequestBody;
import pb.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import pb.locationintelligence.model.GeoRouteResponse;
import pb.locationintelligence.model.TravelCostMatrixResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LIAPIGeoRouteServiceApi {
    private ApiClient apiClient;

    public LIAPIGeoRouteServiceApi() {
        this(Configuration.getDefaultApiClient());
    }

    public LIAPIGeoRouteServiceApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for getRouteByAddress */
    private com.squareup.okhttp.Call getRouteByAddressCall(String startAddress, String endAddress, String db, String country, String intermediateAddresses, String oip, String destinationSrs, String optimizeBy, String returnDistance, String distanceUnit, String returnTime, String timeUnit, String language, String directionsStyle, String segmentGeometryStyle, String primaryNameOnly, String majorRoads, String historicTrafficTimeBucket, String returnDirectionGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'startAddress' is set
        if (startAddress == null) {
            throw new ApiException("Missing the required parameter 'startAddress' when calling getRouteByAddress(Async)");
        }
        
        // verify the required parameter 'endAddress' is set
        if (endAddress == null) {
            throw new ApiException("Missing the required parameter 'endAddress' when calling getRouteByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georoute/v1/route/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (startAddress != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startAddress", startAddress));
        if (endAddress != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endAddress", endAddress));
        if (db != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "db", db));
        if (country != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "country", country));
        if (intermediateAddresses != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "intermediateAddresses", intermediateAddresses));
        if (oip != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "oip", oip));
        if (destinationSrs != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "destinationSrs", destinationSrs));
        if (optimizeBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "optimizeBy", optimizeBy));
        if (returnDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnDistance", returnDistance));
        if (distanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "distanceUnit", distanceUnit));
        if (returnTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnTime", returnTime));
        if (timeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "timeUnit", timeUnit));
        if (language != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "language", language));
        if (directionsStyle != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "directionsStyle", directionsStyle));
        if (segmentGeometryStyle != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "segmentGeometryStyle", segmentGeometryStyle));
        if (primaryNameOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "primaryNameOnly", primaryNameOnly));
        if (majorRoads != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "majorRoads", majorRoads));
        if (historicTrafficTimeBucket != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "historicTrafficTimeBucket", historicTrafficTimeBucket));
        if (returnDirectionGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnDirectionGeometry", returnDirectionGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets Route by Address
     * Routing Directions for Single and Multiple Origin &amp; Destination Inputs. Accepts addresses as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
     * @param startAddress Starting address of the route. (required)
     * @param endAddress Ending address of the route. (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param country Three digit ISO country code (optional, default to USA)
     * @param intermediateAddresses List of intermediate addresses of the route. (optional)
     * @param oip Specifies whether waypoints need to be optimized. (optional, default to false)
     * @param destinationSrs Specifies the desired coordinate system of the returned route. (optional)
     * @param optimizeBy Specifies whether the route should be optimized by time or distance. (optional, default to time)
     * @param returnDistance Specifies whether distance needs to be part of direction information in response. (optional, default to true)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether time needs to be part of direction information in response. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param language Language of travel directions. (optional, default to en)
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse). (optional, default to None)
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All). (optional, default to none)
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street. (optional, default to false)
     * @param majorRoads Whether to include all roads in route calculation or just major roads. (optional, default to false)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response. (optional, default to false)
     * @return GeoRouteResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeoRouteResponse getRouteByAddress(String startAddress, String endAddress, String db, String country, String intermediateAddresses, String oip, String destinationSrs, String optimizeBy, String returnDistance, String distanceUnit, String returnTime, String timeUnit, String language, String directionsStyle, String segmentGeometryStyle, String primaryNameOnly, String majorRoads, String historicTrafficTimeBucket, String returnDirectionGeometry) throws ApiException {
        ApiResponse<GeoRouteResponse> resp = getRouteByAddressWithHttpInfo(startAddress, endAddress, db, country, intermediateAddresses, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry);
        return resp.getData();
    }

    /**
     * Gets Route by Address
     * Routing Directions for Single and Multiple Origin &amp; Destination Inputs. Accepts addresses as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
     * @param startAddress Starting address of the route. (required)
     * @param endAddress Ending address of the route. (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param country Three digit ISO country code (optional, default to USA)
     * @param intermediateAddresses List of intermediate addresses of the route. (optional)
     * @param oip Specifies whether waypoints need to be optimized. (optional, default to false)
     * @param destinationSrs Specifies the desired coordinate system of the returned route. (optional)
     * @param optimizeBy Specifies whether the route should be optimized by time or distance. (optional, default to time)
     * @param returnDistance Specifies whether distance needs to be part of direction information in response. (optional, default to true)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether time needs to be part of direction information in response. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param language Language of travel directions. (optional, default to en)
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse). (optional, default to None)
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All). (optional, default to none)
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street. (optional, default to false)
     * @param majorRoads Whether to include all roads in route calculation or just major roads. (optional, default to false)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response. (optional, default to false)
     * @return ApiResponse&lt;GeoRouteResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeoRouteResponse> getRouteByAddressWithHttpInfo(String startAddress, String endAddress, String db, String country, String intermediateAddresses, String oip, String destinationSrs, String optimizeBy, String returnDistance, String distanceUnit, String returnTime, String timeUnit, String language, String directionsStyle, String segmentGeometryStyle, String primaryNameOnly, String majorRoads, String historicTrafficTimeBucket, String returnDirectionGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getRouteByAddressCall(startAddress, endAddress, db, country, intermediateAddresses, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, null, null);
        Type localVarReturnType = new TypeToken<GeoRouteResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets Route by Address (asynchronously)
     * Routing Directions for Single and Multiple Origin &amp; Destination Inputs. Accepts addresses as input and Returns Point-to-Point and Multi-Point travel directions by various travel modes.
     * @param startAddress Starting address of the route. (required)
     * @param endAddress Ending address of the route. (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param country Three digit ISO country code (optional, default to USA)
     * @param intermediateAddresses List of intermediate addresses of the route. (optional)
     * @param oip Specifies whether waypoints need to be optimized. (optional, default to false)
     * @param destinationSrs Specifies the desired coordinate system of the returned route. (optional)
     * @param optimizeBy Specifies whether the route should be optimized by time or distance. (optional, default to time)
     * @param returnDistance Specifies whether distance needs to be part of direction information in response. (optional, default to true)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether time needs to be part of direction information in response. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param language Language of travel directions. (optional, default to en)
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse). (optional, default to None)
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All). (optional, default to none)
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street. (optional, default to false)
     * @param majorRoads Whether to include all roads in route calculation or just major roads. (optional, default to false)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response. (optional, default to false)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getRouteByAddressAsync(String startAddress, String endAddress, String db, String country, String intermediateAddresses, String oip, String destinationSrs, String optimizeBy, String returnDistance, String distanceUnit, String returnTime, String timeUnit, String language, String directionsStyle, String segmentGeometryStyle, String primaryNameOnly, String majorRoads, String historicTrafficTimeBucket, String returnDirectionGeometry, final ApiCallback<GeoRouteResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getRouteByAddressCall(startAddress, endAddress, db, country, intermediateAddresses, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeoRouteResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getRouteByLocation */
    private com.squareup.okhttp.Call getRouteByLocationCall(String startPoint, String endPoint, String db, String intermediatePoints, String oip, String destinationSrs, String optimizeBy, String returnDistance, String distanceUnit, String returnTime, String timeUnit, String language, String directionsStyle, String segmentGeometryStyle, String primaryNameOnly, String majorRoads, String historicTrafficTimeBucket, String returnDirectionGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'startPoint' is set
        if (startPoint == null) {
            throw new ApiException("Missing the required parameter 'startPoint' when calling getRouteByLocation(Async)");
        }
        
        // verify the required parameter 'endPoint' is set
        if (endPoint == null) {
            throw new ApiException("Missing the required parameter 'endPoint' when calling getRouteByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georoute/v1/route/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (startPoint != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startPoint", startPoint));
        if (endPoint != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endPoint", endPoint));
        if (db != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "db", db));
        if (intermediatePoints != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "intermediatePoints", intermediatePoints));
        if (oip != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "oip", oip));
        if (destinationSrs != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "destinationSrs", destinationSrs));
        if (optimizeBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "optimizeBy", optimizeBy));
        if (returnDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnDistance", returnDistance));
        if (distanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "distanceUnit", distanceUnit));
        if (returnTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnTime", returnTime));
        if (timeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "timeUnit", timeUnit));
        if (language != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "language", language));
        if (directionsStyle != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "directionsStyle", directionsStyle));
        if (segmentGeometryStyle != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "segmentGeometryStyle", segmentGeometryStyle));
        if (primaryNameOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "primaryNameOnly", primaryNameOnly));
        if (majorRoads != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "majorRoads", majorRoads));
        if (historicTrafficTimeBucket != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "historicTrafficTimeBucket", historicTrafficTimeBucket));
        if (returnDirectionGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnDirectionGeometry", returnDirectionGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets Route by Location
     * Returns the fastest or shortest route based on a starting and ending location with optional intermediate points as input.
     * @param startPoint Start Point in &#39;Lat,Long,coordsys&#39; format (required)
     * @param endPoint End Point in &#39;Lat,Long,coordsys&#39; format (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param intermediatePoints List of intermediate points of the route. (optional)
     * @param oip Specifies whether waypoints need to be optimized. (optional, default to false)
     * @param destinationSrs Specifies the desired coordinate system of the returned route. (optional)
     * @param optimizeBy Specifies whether the route should be optimized by time or distance. (optional, default to time)
     * @param returnDistance Specifies whether distance needs to be part of direction information in response. (optional, default to true)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether time needs to be part of direction information in response. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param language Specifies the language of travel directions. (optional, default to en)
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse). (optional, default to None)
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All). (optional, default to none)
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street. (optional, default to false)
     * @param majorRoads Whether to include all roads in route calculation or just major roads. (optional, default to false)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response. (optional, default to false)
     * @return GeoRouteResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeoRouteResponse getRouteByLocation(String startPoint, String endPoint, String db, String intermediatePoints, String oip, String destinationSrs, String optimizeBy, String returnDistance, String distanceUnit, String returnTime, String timeUnit, String language, String directionsStyle, String segmentGeometryStyle, String primaryNameOnly, String majorRoads, String historicTrafficTimeBucket, String returnDirectionGeometry) throws ApiException {
        ApiResponse<GeoRouteResponse> resp = getRouteByLocationWithHttpInfo(startPoint, endPoint, db, intermediatePoints, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry);
        return resp.getData();
    }

    /**
     * Gets Route by Location
     * Returns the fastest or shortest route based on a starting and ending location with optional intermediate points as input.
     * @param startPoint Start Point in &#39;Lat,Long,coordsys&#39; format (required)
     * @param endPoint End Point in &#39;Lat,Long,coordsys&#39; format (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param intermediatePoints List of intermediate points of the route. (optional)
     * @param oip Specifies whether waypoints need to be optimized. (optional, default to false)
     * @param destinationSrs Specifies the desired coordinate system of the returned route. (optional)
     * @param optimizeBy Specifies whether the route should be optimized by time or distance. (optional, default to time)
     * @param returnDistance Specifies whether distance needs to be part of direction information in response. (optional, default to true)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether time needs to be part of direction information in response. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param language Specifies the language of travel directions. (optional, default to en)
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse). (optional, default to None)
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All). (optional, default to none)
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street. (optional, default to false)
     * @param majorRoads Whether to include all roads in route calculation or just major roads. (optional, default to false)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response. (optional, default to false)
     * @return ApiResponse&lt;GeoRouteResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeoRouteResponse> getRouteByLocationWithHttpInfo(String startPoint, String endPoint, String db, String intermediatePoints, String oip, String destinationSrs, String optimizeBy, String returnDistance, String distanceUnit, String returnTime, String timeUnit, String language, String directionsStyle, String segmentGeometryStyle, String primaryNameOnly, String majorRoads, String historicTrafficTimeBucket, String returnDirectionGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getRouteByLocationCall(startPoint, endPoint, db, intermediatePoints, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, null, null);
        Type localVarReturnType = new TypeToken<GeoRouteResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets Route by Location (asynchronously)
     * Returns the fastest or shortest route based on a starting and ending location with optional intermediate points as input.
     * @param startPoint Start Point in &#39;Lat,Long,coordsys&#39; format (required)
     * @param endPoint End Point in &#39;Lat,Long,coordsys&#39; format (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param intermediatePoints List of intermediate points of the route. (optional)
     * @param oip Specifies whether waypoints need to be optimized. (optional, default to false)
     * @param destinationSrs Specifies the desired coordinate system of the returned route. (optional)
     * @param optimizeBy Specifies whether the route should be optimized by time or distance. (optional, default to time)
     * @param returnDistance Specifies whether distance needs to be part of direction information in response. (optional, default to true)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether time needs to be part of direction information in response. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param language Specifies the language of travel directions. (optional, default to en)
     * @param directionsStyle Specifies whether route directions text is to be returned in the response and in what detail (Normal or Terse). (optional, default to None)
     * @param segmentGeometryStyle Specifies whether the route geometry is to be returned in the response and in what detail (End or All). (optional, default to none)
     * @param primaryNameOnly If true then only the primary street name is returned otherwise all the names for a street. (optional, default to false)
     * @param majorRoads Whether to include all roads in route calculation or just major roads. (optional, default to false)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @param returnDirectionGeometry Whether to include geometry associated with each route instruction in response. (optional, default to false)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getRouteByLocationAsync(String startPoint, String endPoint, String db, String intermediatePoints, String oip, String destinationSrs, String optimizeBy, String returnDistance, String distanceUnit, String returnTime, String timeUnit, String language, String directionsStyle, String segmentGeometryStyle, String primaryNameOnly, String majorRoads, String historicTrafficTimeBucket, String returnDirectionGeometry, final ApiCallback<GeoRouteResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getRouteByLocationCall(startPoint, endPoint, db, intermediatePoints, oip, destinationSrs, optimizeBy, returnDistance, distanceUnit, returnTime, timeUnit, language, directionsStyle, segmentGeometryStyle, primaryNameOnly, majorRoads, historicTrafficTimeBucket, returnDirectionGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeoRouteResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getTravelCostMatrixByAddress */
    private com.squareup.okhttp.Call getTravelCostMatrixByAddressCall(String startAddresses, String endAddresses, String db, String country, String optimizeBy, String returnDistance, String destinationSrs, String distanceUnit, String returnTime, String timeUnit, String majorRoads, String returnOptimalRoutesOnly, String historicTrafficTimeBucket, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'startAddresses' is set
        if (startAddresses == null) {
            throw new ApiException("Missing the required parameter 'startAddresses' when calling getTravelCostMatrixByAddress(Async)");
        }
        
        // verify the required parameter 'endAddresses' is set
        if (endAddresses == null) {
            throw new ApiException("Missing the required parameter 'endAddresses' when calling getTravelCostMatrixByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georoute/v1/travelcostmatrix/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (startAddresses != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startAddresses", startAddresses));
        if (endAddresses != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endAddresses", endAddresses));
        if (db != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "db", db));
        if (country != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "country", country));
        if (optimizeBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "optimizeBy", optimizeBy));
        if (returnDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnDistance", returnDistance));
        if (destinationSrs != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "destinationSrs", destinationSrs));
        if (distanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "distanceUnit", distanceUnit));
        if (returnTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnTime", returnTime));
        if (timeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "timeUnit", timeUnit));
        if (majorRoads != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "majorRoads", majorRoads));
        if (returnOptimalRoutesOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnOptimalRoutesOnly", returnOptimalRoutesOnly));
        if (historicTrafficTimeBucket != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "historicTrafficTimeBucket", historicTrafficTimeBucket));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets Cost Matrix by Address
     * Calculates the travel time and distances between an array of start and end addresses.
     * @param startAddresses Start locations in text based addresses. (required)
     * @param endAddresses End locations in text based addresses. (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param country 3 Digit ISO country code. (optional, default to USA)
     * @param optimizeBy Specifies the type of optimizing to use for the route (time/distance). (optional, default to time)
     * @param returnDistance Specifies whether to return the travel distance in the response or not. (optional, default to true)
     * @param destinationSrs Coordinate system used for the returned routes. (optional)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether to return the travel time in the response or not. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param majorRoads Whether to include all roads in routes calculation or just major roads. (optional, default to false)
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination. (optional, default to true)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @return TravelCostMatrixResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TravelCostMatrixResponse getTravelCostMatrixByAddress(String startAddresses, String endAddresses, String db, String country, String optimizeBy, String returnDistance, String destinationSrs, String distanceUnit, String returnTime, String timeUnit, String majorRoads, String returnOptimalRoutesOnly, String historicTrafficTimeBucket) throws ApiException {
        ApiResponse<TravelCostMatrixResponse> resp = getTravelCostMatrixByAddressWithHttpInfo(startAddresses, endAddresses, db, country, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket);
        return resp.getData();
    }

    /**
     * Gets Cost Matrix by Address
     * Calculates the travel time and distances between an array of start and end addresses.
     * @param startAddresses Start locations in text based addresses. (required)
     * @param endAddresses End locations in text based addresses. (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param country 3 Digit ISO country code. (optional, default to USA)
     * @param optimizeBy Specifies the type of optimizing to use for the route (time/distance). (optional, default to time)
     * @param returnDistance Specifies whether to return the travel distance in the response or not. (optional, default to true)
     * @param destinationSrs Coordinate system used for the returned routes. (optional)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether to return the travel time in the response or not. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param majorRoads Whether to include all roads in routes calculation or just major roads. (optional, default to false)
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination. (optional, default to true)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @return ApiResponse&lt;TravelCostMatrixResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TravelCostMatrixResponse> getTravelCostMatrixByAddressWithHttpInfo(String startAddresses, String endAddresses, String db, String country, String optimizeBy, String returnDistance, String destinationSrs, String distanceUnit, String returnTime, String timeUnit, String majorRoads, String returnOptimalRoutesOnly, String historicTrafficTimeBucket) throws ApiException {
        com.squareup.okhttp.Call call = getTravelCostMatrixByAddressCall(startAddresses, endAddresses, db, country, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, null, null);
        Type localVarReturnType = new TypeToken<TravelCostMatrixResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets Cost Matrix by Address (asynchronously)
     * Calculates the travel time and distances between an array of start and end addresses.
     * @param startAddresses Start locations in text based addresses. (required)
     * @param endAddresses End locations in text based addresses. (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param country 3 Digit ISO country code. (optional, default to USA)
     * @param optimizeBy Specifies the type of optimizing to use for the route (time/distance). (optional, default to time)
     * @param returnDistance Specifies whether to return the travel distance in the response or not. (optional, default to true)
     * @param destinationSrs Coordinate system used for the returned routes. (optional)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether to return the travel time in the response or not. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param majorRoads Whether to include all roads in routes calculation or just major roads. (optional, default to false)
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination. (optional, default to true)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getTravelCostMatrixByAddressAsync(String startAddresses, String endAddresses, String db, String country, String optimizeBy, String returnDistance, String destinationSrs, String distanceUnit, String returnTime, String timeUnit, String majorRoads, String returnOptimalRoutesOnly, String historicTrafficTimeBucket, final ApiCallback<TravelCostMatrixResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getTravelCostMatrixByAddressCall(startAddresses, endAddresses, db, country, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<TravelCostMatrixResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getTravelCostMatrixByLocation */
    private com.squareup.okhttp.Call getTravelCostMatrixByLocationCall(String startPoints, String endPoints, String db, String optimizeBy, String returnDistance, String destinationSrs, String distanceUnit, String returnTime, String timeUnit, String majorRoads, String returnOptimalRoutesOnly, String historicTrafficTimeBucket, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'startPoints' is set
        if (startPoints == null) {
            throw new ApiException("Missing the required parameter 'startPoints' when calling getTravelCostMatrixByLocation(Async)");
        }
        
        // verify the required parameter 'endPoints' is set
        if (endPoints == null) {
            throw new ApiException("Missing the required parameter 'endPoints' when calling getTravelCostMatrixByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georoute/v1/travelcostmatrix/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (startPoints != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startPoints", startPoints));
        if (endPoints != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endPoints", endPoints));
        if (db != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "db", db));
        if (optimizeBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "optimizeBy", optimizeBy));
        if (returnDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnDistance", returnDistance));
        if (destinationSrs != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "destinationSrs", destinationSrs));
        if (distanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "distanceUnit", distanceUnit));
        if (returnTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnTime", returnTime));
        if (timeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "timeUnit", timeUnit));
        if (majorRoads != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "majorRoads", majorRoads));
        if (returnOptimalRoutesOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "returnOptimalRoutesOnly", returnOptimalRoutesOnly));
        if (historicTrafficTimeBucket != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "historicTrafficTimeBucket", historicTrafficTimeBucket));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets Cost Matrix by Location
     * GeoRoute&#39;s &#39;Travel Cost Matrix By Location&#39; service calculates the travel time and distances between an array of start and end points based on location coordinates.
     * @param startPoints The address to be searched. (required)
     * @param endPoints The address to be searched. (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param optimizeBy Specifies whether routes should be optimized by time or distance. (optional, default to time)
     * @param returnDistance Specifies whether distance needs to be returned in response. (optional, default to true)
     * @param destinationSrs Specifies the desired coordinate system of returned routes. (optional)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether time needs to be returned in response. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param majorRoads Whether to include all roads in routes calculation or just major roads. (optional, default to false)
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination. (optional, default to true)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @return TravelCostMatrixResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TravelCostMatrixResponse getTravelCostMatrixByLocation(String startPoints, String endPoints, String db, String optimizeBy, String returnDistance, String destinationSrs, String distanceUnit, String returnTime, String timeUnit, String majorRoads, String returnOptimalRoutesOnly, String historicTrafficTimeBucket) throws ApiException {
        ApiResponse<TravelCostMatrixResponse> resp = getTravelCostMatrixByLocationWithHttpInfo(startPoints, endPoints, db, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket);
        return resp.getData();
    }

    /**
     * Gets Cost Matrix by Location
     * GeoRoute&#39;s &#39;Travel Cost Matrix By Location&#39; service calculates the travel time and distances between an array of start and end points based on location coordinates.
     * @param startPoints The address to be searched. (required)
     * @param endPoints The address to be searched. (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param optimizeBy Specifies whether routes should be optimized by time or distance. (optional, default to time)
     * @param returnDistance Specifies whether distance needs to be returned in response. (optional, default to true)
     * @param destinationSrs Specifies the desired coordinate system of returned routes. (optional)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether time needs to be returned in response. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param majorRoads Whether to include all roads in routes calculation or just major roads. (optional, default to false)
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination. (optional, default to true)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @return ApiResponse&lt;TravelCostMatrixResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TravelCostMatrixResponse> getTravelCostMatrixByLocationWithHttpInfo(String startPoints, String endPoints, String db, String optimizeBy, String returnDistance, String destinationSrs, String distanceUnit, String returnTime, String timeUnit, String majorRoads, String returnOptimalRoutesOnly, String historicTrafficTimeBucket) throws ApiException {
        com.squareup.okhttp.Call call = getTravelCostMatrixByLocationCall(startPoints, endPoints, db, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, null, null);
        Type localVarReturnType = new TypeToken<TravelCostMatrixResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets Cost Matrix by Location (asynchronously)
     * GeoRoute&#39;s &#39;Travel Cost Matrix By Location&#39; service calculates the travel time and distances between an array of start and end points based on location coordinates.
     * @param startPoints The address to be searched. (required)
     * @param endPoints The address to be searched. (required)
     * @param db Mode of commute. (optional, default to driving)
     * @param optimizeBy Specifies whether routes should be optimized by time or distance. (optional, default to time)
     * @param returnDistance Specifies whether distance needs to be returned in response. (optional, default to true)
     * @param destinationSrs Specifies the desired coordinate system of returned routes. (optional)
     * @param distanceUnit Return Distance Unit such as ft(Foot), km(Kilometer), mi(Mile), m(Meter) or yd(Yard). (optional, default to m)
     * @param returnTime Specifies whether time needs to be returned in response. (optional, default to true)
     * @param timeUnit Return time unit such as min(Minute), h(Hour), s(Second) or msec(Millisecond). (optional, default to min)
     * @param majorRoads Whether to include all roads in routes calculation or just major roads. (optional, default to false)
     * @param returnOptimalRoutesOnly Specifies whether to return only the optimized route for each start and end point combination. (optional, default to true)
     * @param historicTrafficTimeBucket Specifies whether routing calculation uses the historic traffic speeds. (optional, default to None)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getTravelCostMatrixByLocationAsync(String startPoints, String endPoints, String db, String optimizeBy, String returnDistance, String destinationSrs, String distanceUnit, String returnTime, String timeUnit, String majorRoads, String returnOptimalRoutesOnly, String historicTrafficTimeBucket, final ApiCallback<TravelCostMatrixResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getTravelCostMatrixByLocationCall(startPoints, endPoints, db, optimizeBy, returnDistance, destinationSrs, distanceUnit, returnTime, timeUnit, majorRoads, returnOptimalRoutesOnly, historicTrafficTimeBucket, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<TravelCostMatrixResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
