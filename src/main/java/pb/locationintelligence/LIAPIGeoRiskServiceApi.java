/**
 * Location Intelligence APIs
 * Incorporate our extensive geodata into everyday applications, business processes and workflows.
 *
 * OpenAPI spec version: 8.5.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package pb.locationintelligence;

import pb.ApiCallback;
import pb.ApiClient;
import pb.ApiException;
import pb.ApiResponse;
import pb.Configuration;
import pb.Pair;
import pb.ProgressRequestBody;
import pb.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import pb.locationintelligence.model.CrimeRiskResponse;
import pb.locationintelligence.model.CrimeRiskByAddressRequest;
import pb.locationintelligence.model.CrimeRiskResponseList;
import pb.locationintelligence.model.CrimeRiskLocationResponse;
import pb.locationintelligence.model.CrimeRiskByLocationRequest;
import pb.locationintelligence.model.CrimeRiskLocationResponseList;
import pb.locationintelligence.model.WaterBodyResponse;
import pb.locationintelligence.model.DistanceToFloodHazardResponse;
import pb.locationintelligence.model.DistanceToFloodHazardAddressRequest;
import pb.locationintelligence.model.WaterBodyLocationResponse;
import pb.locationintelligence.model.DistanceToFloodHazardLocationResponse;
import pb.locationintelligence.model.DistanceToFloodHazardLocationRequest;
import pb.locationintelligence.model.EarthquakeHistory;
import pb.locationintelligence.model.EarthquakeRiskResponse;
import pb.locationintelligence.model.EarthquakeRiskByAddressRequest;
import pb.locationintelligence.model.EarthquakeRiskResponseList;
import pb.locationintelligence.model.EarthquakeRiskLocationResponse;
import pb.locationintelligence.model.EarthquakeRiskLocationResponseList;
import pb.locationintelligence.model.EarthquakeRiskByLocationRequest;
import pb.locationintelligence.model.FireHistory;
import pb.locationintelligence.model.FireRiskResponse;
import pb.locationintelligence.model.FireRiskByAddressRequest;
import pb.locationintelligence.model.FireRiskResponseList;
import pb.locationintelligence.model.FireRiskLocationResponse;
import pb.locationintelligence.model.FireRiskLocationResponseList;
import pb.locationintelligence.model.FireRiskByLocationRequest;
import pb.locationintelligence.model.FireStations;
import pb.locationintelligence.model.FireStationsLocation;
import pb.locationintelligence.model.FloodRiskResponse;
import pb.locationintelligence.model.FloodRiskByAddressRequest;
import pb.locationintelligence.model.FloodRiskResponseList;
import pb.locationintelligence.model.FloodRiskLocationResponse;
import pb.locationintelligence.model.FloodRiskByLocationRequest;
import pb.locationintelligence.model.FloodRiskLocationResponseList;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LIAPIGeoRiskServiceApi {
    private ApiClient apiClient;

    public LIAPIGeoRiskServiceApi() {
        this(Configuration.getDefaultApiClient());
    }

    public LIAPIGeoRiskServiceApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for getCrimeRiskByAddress */
    private com.squareup.okhttp.Call getCrimeRiskByAddressCall(String address, String type, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getCrimeRiskByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/crime/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (type != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets CrimeRiskResponse
     * Returns the crime data or crime indexes for a given address input.
     * @param address Free-form address text. (required)
     * @param type Type of crime like violent crime, property crime, etc., multiple crime type indexes could be requested as comma separated values with &#39;all&#39; as default.) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return CrimeRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public CrimeRiskResponse getCrimeRiskByAddress(String address, String type, String includeGeometry) throws ApiException {
        ApiResponse<CrimeRiskResponse> resp = getCrimeRiskByAddressWithHttpInfo(address, type, includeGeometry);
        return resp.getData();
    }

    /**
     * Gets CrimeRiskResponse
     * Returns the crime data or crime indexes for a given address input.
     * @param address Free-form address text. (required)
     * @param type Type of crime like violent crime, property crime, etc., multiple crime type indexes could be requested as comma separated values with &#39;all&#39; as default.) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;CrimeRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<CrimeRiskResponse> getCrimeRiskByAddressWithHttpInfo(String address, String type, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getCrimeRiskByAddressCall(address, type, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<CrimeRiskResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets CrimeRiskResponse (asynchronously)
     * Returns the crime data or crime indexes for a given address input.
     * @param address Free-form address text. (required)
     * @param type Type of crime like violent crime, property crime, etc., multiple crime type indexes could be requested as comma separated values with &#39;all&#39; as default.) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCrimeRiskByAddressAsync(String address, String type, String includeGeometry, final ApiCallback<CrimeRiskResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCrimeRiskByAddressCall(address, type, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<CrimeRiskResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getCrimeRiskByAddressBatch */
    private com.squareup.okhttp.Call getCrimeRiskByAddressBatchCall(CrimeRiskByAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/crime/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting crime risk by address
     * Batch method for getting crime risk by address
     * @param body  (optional)
     * @return CrimeRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public CrimeRiskResponseList getCrimeRiskByAddressBatch(CrimeRiskByAddressRequest body) throws ApiException {
        ApiResponse<CrimeRiskResponseList> resp = getCrimeRiskByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting crime risk by address
     * Batch method for getting crime risk by address
     * @param body  (optional)
     * @return ApiResponse&lt;CrimeRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<CrimeRiskResponseList> getCrimeRiskByAddressBatchWithHttpInfo(CrimeRiskByAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getCrimeRiskByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<CrimeRiskResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting crime risk by address (asynchronously)
     * Batch method for getting crime risk by address
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCrimeRiskByAddressBatchAsync(CrimeRiskByAddressRequest body, final ApiCallback<CrimeRiskResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCrimeRiskByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<CrimeRiskResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getCrimeRiskByLocation */
    private com.squareup.okhttp.Call getCrimeRiskByLocationCall(String longitude, String latitude, String type, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getCrimeRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getCrimeRiskByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/crime/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (type != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets CrimeRiskResponse
     * Returns the crime data or crime indexes for a given location.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type Refers to crime type. Valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return CrimeRiskLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public CrimeRiskLocationResponse getCrimeRiskByLocation(String longitude, String latitude, String type, String includeGeometry) throws ApiException {
        ApiResponse<CrimeRiskLocationResponse> resp = getCrimeRiskByLocationWithHttpInfo(longitude, latitude, type, includeGeometry);
        return resp.getData();
    }

    /**
     * Gets CrimeRiskResponse
     * Returns the crime data or crime indexes for a given location.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type Refers to crime type. Valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;CrimeRiskLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<CrimeRiskLocationResponse> getCrimeRiskByLocationWithHttpInfo(String longitude, String latitude, String type, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getCrimeRiskByLocationCall(longitude, latitude, type, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<CrimeRiskLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets CrimeRiskResponse (asynchronously)
     * Returns the crime data or crime indexes for a given location.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type Refers to crime type. Valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCrimeRiskByLocationAsync(String longitude, String latitude, String type, String includeGeometry, final ApiCallback<CrimeRiskLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCrimeRiskByLocationCall(longitude, latitude, type, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<CrimeRiskLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getCrimeRiskByLocationBatch */
    private com.squareup.okhttp.Call getCrimeRiskByLocationBatchCall(CrimeRiskByLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/crime/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting crime risk by location
     * Batch method for getting crime risk by location
     * @param body  (optional)
     * @return CrimeRiskLocationResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public CrimeRiskLocationResponseList getCrimeRiskByLocationBatch(CrimeRiskByLocationRequest body) throws ApiException {
        ApiResponse<CrimeRiskLocationResponseList> resp = getCrimeRiskByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting crime risk by location
     * Batch method for getting crime risk by location
     * @param body  (optional)
     * @return ApiResponse&lt;CrimeRiskLocationResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<CrimeRiskLocationResponseList> getCrimeRiskByLocationBatchWithHttpInfo(CrimeRiskByLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getCrimeRiskByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<CrimeRiskLocationResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting crime risk by location (asynchronously)
     * Batch method for getting crime risk by location
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCrimeRiskByLocationBatchAsync(CrimeRiskByLocationRequest body, final ApiCallback<CrimeRiskLocationResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCrimeRiskByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<CrimeRiskLocationResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getDistanceToFloodHazardByAddress */
    private com.squareup.okhttp.Call getDistanceToFloodHazardByAddressCall(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getDistanceToFloodHazardByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/shoreline/distancetofloodhazard/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (waterBodyType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "waterBodyType", waterBodyType));
        if (searchDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchDistance", searchDistance));
        if (searchDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchDistanceUnit", searchDistanceUnit));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets WaterBodyResponse
     * Gets WaterBodyResponse
     * @param address The address of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return WaterBodyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public WaterBodyResponse getDistanceToFloodHazardByAddress(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        ApiResponse<WaterBodyResponse> resp = getDistanceToFloodHazardByAddressWithHttpInfo(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit);
        return resp.getData();
    }

    /**
     * Gets WaterBodyResponse
     * Gets WaterBodyResponse
     * @param address The address of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return ApiResponse&lt;WaterBodyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<WaterBodyResponse> getDistanceToFloodHazardByAddressWithHttpInfo(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        com.squareup.okhttp.Call call = getDistanceToFloodHazardByAddressCall(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, null, null);
        Type localVarReturnType = new TypeToken<WaterBodyResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets WaterBodyResponse (asynchronously)
     * Gets WaterBodyResponse
     * @param address The address of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getDistanceToFloodHazardByAddressAsync(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback<WaterBodyResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getDistanceToFloodHazardByAddressCall(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<WaterBodyResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getDistanceToFloodHazardByAddressBatch */
    private com.squareup.okhttp.Call getDistanceToFloodHazardByAddressBatchCall(DistanceToFloodHazardAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/shoreline/distancetofloodhazard/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting Water Bodies by address
     * Batch method for getting Water Bodies by address
     * @param body  (optional)
     * @return DistanceToFloodHazardResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public DistanceToFloodHazardResponse getDistanceToFloodHazardByAddressBatch(DistanceToFloodHazardAddressRequest body) throws ApiException {
        ApiResponse<DistanceToFloodHazardResponse> resp = getDistanceToFloodHazardByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting Water Bodies by address
     * Batch method for getting Water Bodies by address
     * @param body  (optional)
     * @return ApiResponse&lt;DistanceToFloodHazardResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<DistanceToFloodHazardResponse> getDistanceToFloodHazardByAddressBatchWithHttpInfo(DistanceToFloodHazardAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getDistanceToFloodHazardByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting Water Bodies by address (asynchronously)
     * Batch method for getting Water Bodies by address
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getDistanceToFloodHazardByAddressBatchAsync(DistanceToFloodHazardAddressRequest body, final ApiCallback<DistanceToFloodHazardResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getDistanceToFloodHazardByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getDistanceToFloodHazardByLocation */
    private com.squareup.okhttp.Call getDistanceToFloodHazardByLocationCall(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getDistanceToFloodHazardByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getDistanceToFloodHazardByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/shoreline/distancetofloodhazard/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (waterBodyType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "waterBodyType", waterBodyType));
        if (searchDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchDistance", searchDistance));
        if (searchDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchDistanceUnit", searchDistanceUnit));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets WaterBodyResponse
     * Gets WaterBodyResponse
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return WaterBodyLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public WaterBodyLocationResponse getDistanceToFloodHazardByLocation(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        ApiResponse<WaterBodyLocationResponse> resp = getDistanceToFloodHazardByLocationWithHttpInfo(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit);
        return resp.getData();
    }

    /**
     * Gets WaterBodyResponse
     * Gets WaterBodyResponse
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return ApiResponse&lt;WaterBodyLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<WaterBodyLocationResponse> getDistanceToFloodHazardByLocationWithHttpInfo(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        com.squareup.okhttp.Call call = getDistanceToFloodHazardByLocationCall(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, null, null);
        Type localVarReturnType = new TypeToken<WaterBodyLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets WaterBodyResponse (asynchronously)
     * Gets WaterBodyResponse
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getDistanceToFloodHazardByLocationAsync(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback<WaterBodyLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getDistanceToFloodHazardByLocationCall(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<WaterBodyLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getDistanceToFloodHazardByLocationBatch */
    private com.squareup.okhttp.Call getDistanceToFloodHazardByLocationBatchCall(DistanceToFloodHazardLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/shoreline/distancetofloodhazard/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting Water Bodies by location
     * Batch method for getting Water Bodies by location
     * @param body  (optional)
     * @return DistanceToFloodHazardLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public DistanceToFloodHazardLocationResponse getDistanceToFloodHazardByLocationBatch(DistanceToFloodHazardLocationRequest body) throws ApiException {
        ApiResponse<DistanceToFloodHazardLocationResponse> resp = getDistanceToFloodHazardByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting Water Bodies by location
     * Batch method for getting Water Bodies by location
     * @param body  (optional)
     * @return ApiResponse&lt;DistanceToFloodHazardLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<DistanceToFloodHazardLocationResponse> getDistanceToFloodHazardByLocationBatchWithHttpInfo(DistanceToFloodHazardLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getDistanceToFloodHazardByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting Water Bodies by location (asynchronously)
     * Batch method for getting Water Bodies by location
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getDistanceToFloodHazardByLocationBatchAsync(DistanceToFloodHazardLocationRequest body, final ApiCallback<DistanceToFloodHazardLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getDistanceToFloodHazardByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeHistory */
    private com.squareup.okhttp.Call getEarthquakeHistoryCall(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'postCode' is set
        if (postCode == null) {
            throw new ApiException("Missing the required parameter 'postCode' when calling getEarthquakeHistory(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/earthquakehistory".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (postCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "postCode", postCode));
        if (startDate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startDate", startDate));
        if (endDate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endDate", endDate));
        if (minMagnitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "minMagnitude", minMagnitude));
        if (maxMagnitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxMagnitude", maxMagnitude));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets EarthquakeHistory
     * Gets EarthquakeHistory
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @return EarthquakeHistory
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeHistory getEarthquakeHistory(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates) throws ApiException {
        ApiResponse<EarthquakeHistory> resp = getEarthquakeHistoryWithHttpInfo(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates);
        return resp.getData();
    }

    /**
     * Gets EarthquakeHistory
     * Gets EarthquakeHistory
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @return ApiResponse&lt;EarthquakeHistory&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeHistory> getEarthquakeHistoryWithHttpInfo(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeHistoryCall(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeHistory>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets EarthquakeHistory (asynchronously)
     * Gets EarthquakeHistory
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeHistoryAsync(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates, final ApiCallback<EarthquakeHistory> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeHistoryCall(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeHistory>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeRiskByAddress */
    private com.squareup.okhttp.Call getEarthquakeRiskByAddressCall(String address, String richterValue, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getEarthquakeRiskByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/earthquake/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (richterValue != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "richterValue", richterValue));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets EarthquakeRiskResponse
     * Returns the count of earthquake events for various richter measurements and values for an input address.
     * @param address Free-form address text (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return EarthquakeRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeRiskResponse getEarthquakeRiskByAddress(String address, String richterValue, String includeGeometry) throws ApiException {
        ApiResponse<EarthquakeRiskResponse> resp = getEarthquakeRiskByAddressWithHttpInfo(address, richterValue, includeGeometry);
        return resp.getData();
    }

    /**
     * Gets EarthquakeRiskResponse
     * Returns the count of earthquake events for various richter measurements and values for an input address.
     * @param address Free-form address text (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;EarthquakeRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeRiskResponse> getEarthquakeRiskByAddressWithHttpInfo(String address, String richterValue, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeRiskByAddressCall(address, richterValue, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets EarthquakeRiskResponse (asynchronously)
     * Returns the count of earthquake events for various richter measurements and values for an input address.
     * @param address Free-form address text (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeRiskByAddressAsync(String address, String richterValue, String includeGeometry, final ApiCallback<EarthquakeRiskResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeRiskByAddressCall(address, richterValue, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeRiskByAddressBatch */
    private com.squareup.okhttp.Call getEarthquakeRiskByAddressBatchCall(EarthquakeRiskByAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/earthquake/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting earthquake risk by address
     * Batch method for getting earthquake risk by address
     * @param body  (optional)
     * @return EarthquakeRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeRiskResponseList getEarthquakeRiskByAddressBatch(EarthquakeRiskByAddressRequest body) throws ApiException {
        ApiResponse<EarthquakeRiskResponseList> resp = getEarthquakeRiskByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting earthquake risk by address
     * Batch method for getting earthquake risk by address
     * @param body  (optional)
     * @return ApiResponse&lt;EarthquakeRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeRiskResponseList> getEarthquakeRiskByAddressBatchWithHttpInfo(EarthquakeRiskByAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeRiskByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting earthquake risk by address (asynchronously)
     * Batch method for getting earthquake risk by address
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeRiskByAddressBatchAsync(EarthquakeRiskByAddressRequest body, final ApiCallback<EarthquakeRiskResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeRiskByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeRiskByLocation */
    private com.squareup.okhttp.Call getEarthquakeRiskByLocationCall(String longitude, String latitude, String richterValue, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getEarthquakeRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getEarthquakeRiskByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/earthquake/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (richterValue != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "richterValue", richterValue));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets EarthquakeRiskResponse
     * Gets EarthquakeRiskResponse
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return EarthquakeRiskLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeRiskLocationResponse getEarthquakeRiskByLocation(String longitude, String latitude, String richterValue, String includeGeometry) throws ApiException {
        ApiResponse<EarthquakeRiskLocationResponse> resp = getEarthquakeRiskByLocationWithHttpInfo(longitude, latitude, richterValue, includeGeometry);
        return resp.getData();
    }

    /**
     * Gets EarthquakeRiskResponse
     * Gets EarthquakeRiskResponse
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;EarthquakeRiskLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeRiskLocationResponse> getEarthquakeRiskByLocationWithHttpInfo(String longitude, String latitude, String richterValue, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeRiskByLocationCall(longitude, latitude, richterValue, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets EarthquakeRiskResponse (asynchronously)
     * Gets EarthquakeRiskResponse
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeRiskByLocationAsync(String longitude, String latitude, String richterValue, String includeGeometry, final ApiCallback<EarthquakeRiskLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeRiskByLocationCall(longitude, latitude, richterValue, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeRiskLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeRiskByLocationBatch */
    private com.squareup.okhttp.Call getEarthquakeRiskByLocationBatchCall(EarthquakeRiskByLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/earthquake/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting earthquake risk by location
     * Batch method for getting earthquake risk by location
     * @param body  (optional)
     * @return EarthquakeRiskLocationResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeRiskLocationResponseList getEarthquakeRiskByLocationBatch(EarthquakeRiskByLocationRequest body) throws ApiException {
        ApiResponse<EarthquakeRiskLocationResponseList> resp = getEarthquakeRiskByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting earthquake risk by location
     * Batch method for getting earthquake risk by location
     * @param body  (optional)
     * @return ApiResponse&lt;EarthquakeRiskLocationResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeRiskLocationResponseList> getEarthquakeRiskByLocationBatchWithHttpInfo(EarthquakeRiskByLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeRiskByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskLocationResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting earthquake risk by location (asynchronously)
     * Batch method for getting earthquake risk by location
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeRiskByLocationBatchAsync(EarthquakeRiskByLocationRequest body, final ApiCallback<EarthquakeRiskLocationResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeRiskByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeRiskLocationResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireHistory */
    private com.squareup.okhttp.Call getFireHistoryCall(String postCode, String startDate, String endDate, String maxCandidates, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'postCode' is set
        if (postCode == null) {
            throw new ApiException("Missing the required parameter 'postCode' when calling getFireHistory(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/firehistory".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (postCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "postCode", postCode));
        if (startDate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startDate", startDate));
        if (endDate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endDate", endDate));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets FireHistory
     * Gets FireHistory
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @return FireHistory
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireHistory getFireHistory(String postCode, String startDate, String endDate, String maxCandidates) throws ApiException {
        ApiResponse<FireHistory> resp = getFireHistoryWithHttpInfo(postCode, startDate, endDate, maxCandidates);
        return resp.getData();
    }

    /**
     * Gets FireHistory
     * Gets FireHistory
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @return ApiResponse&lt;FireHistory&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireHistory> getFireHistoryWithHttpInfo(String postCode, String startDate, String endDate, String maxCandidates) throws ApiException {
        com.squareup.okhttp.Call call = getFireHistoryCall(postCode, startDate, endDate, maxCandidates, null, null);
        Type localVarReturnType = new TypeToken<FireHistory>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets FireHistory (asynchronously)
     * Gets FireHistory
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireHistoryAsync(String postCode, String startDate, String endDate, String maxCandidates, final ApiCallback<FireHistory> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireHistoryCall(postCode, startDate, endDate, maxCandidates, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireHistory>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireRiskByAddress */
    private com.squareup.okhttp.Call getFireRiskByAddressCall(String address, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getFireRiskByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/fire/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets FireRiskResponse
     * Returns the fire data based on address input.
     * @param address Free-form address text (required)
     * @return FireRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireRiskResponse getFireRiskByAddress(String address) throws ApiException {
        ApiResponse<FireRiskResponse> resp = getFireRiskByAddressWithHttpInfo(address);
        return resp.getData();
    }

    /**
     * Gets FireRiskResponse
     * Returns the fire data based on address input.
     * @param address Free-form address text (required)
     * @return ApiResponse&lt;FireRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireRiskResponse> getFireRiskByAddressWithHttpInfo(String address) throws ApiException {
        com.squareup.okhttp.Call call = getFireRiskByAddressCall(address, null, null);
        Type localVarReturnType = new TypeToken<FireRiskResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets FireRiskResponse (asynchronously)
     * Returns the fire data based on address input.
     * @param address Free-form address text (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireRiskByAddressAsync(String address, final ApiCallback<FireRiskResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireRiskByAddressCall(address, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireRiskResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireRiskByAddressBatch */
    private com.squareup.okhttp.Call getFireRiskByAddressBatchCall(FireRiskByAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/fire/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting fire risk by address
     * Batch method for getting fire risk by address
     * @param body  (optional)
     * @return FireRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireRiskResponseList getFireRiskByAddressBatch(FireRiskByAddressRequest body) throws ApiException {
        ApiResponse<FireRiskResponseList> resp = getFireRiskByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting fire risk by address
     * Batch method for getting fire risk by address
     * @param body  (optional)
     * @return ApiResponse&lt;FireRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireRiskResponseList> getFireRiskByAddressBatchWithHttpInfo(FireRiskByAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getFireRiskByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<FireRiskResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting fire risk by address (asynchronously)
     * Batch method for getting fire risk by address
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireRiskByAddressBatchAsync(FireRiskByAddressRequest body, final ApiCallback<FireRiskResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireRiskByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireRiskResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireRiskByLocation */
    private com.squareup.okhttp.Call getFireRiskByLocationCall(String longitude, String latitude, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getFireRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getFireRiskByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/fire/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets FireRiskResponse
     * Returns the fire data based on location input.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @return FireRiskLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireRiskLocationResponse getFireRiskByLocation(String longitude, String latitude) throws ApiException {
        ApiResponse<FireRiskLocationResponse> resp = getFireRiskByLocationWithHttpInfo(longitude, latitude);
        return resp.getData();
    }

    /**
     * Gets FireRiskResponse
     * Returns the fire data based on location input.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @return ApiResponse&lt;FireRiskLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireRiskLocationResponse> getFireRiskByLocationWithHttpInfo(String longitude, String latitude) throws ApiException {
        com.squareup.okhttp.Call call = getFireRiskByLocationCall(longitude, latitude, null, null);
        Type localVarReturnType = new TypeToken<FireRiskLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets FireRiskResponse (asynchronously)
     * Returns the fire data based on location input.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireRiskByLocationAsync(String longitude, String latitude, final ApiCallback<FireRiskLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireRiskByLocationCall(longitude, latitude, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireRiskLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireRiskByLocationBatch */
    private com.squareup.okhttp.Call getFireRiskByLocationBatchCall(FireRiskByLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/fire/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting fire risk by location
     * Batch method for getting fire risk by location
     * @param body  (optional)
     * @return FireRiskLocationResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireRiskLocationResponseList getFireRiskByLocationBatch(FireRiskByLocationRequest body) throws ApiException {
        ApiResponse<FireRiskLocationResponseList> resp = getFireRiskByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting fire risk by location
     * Batch method for getting fire risk by location
     * @param body  (optional)
     * @return ApiResponse&lt;FireRiskLocationResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireRiskLocationResponseList> getFireRiskByLocationBatchWithHttpInfo(FireRiskByLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getFireRiskByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<FireRiskLocationResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting fire risk by location (asynchronously)
     * Batch method for getting fire risk by location
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireRiskByLocationBatchAsync(FireRiskByLocationRequest body, final ApiCallback<FireRiskLocationResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireRiskByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireRiskLocationResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireStationByAddress */
    private com.squareup.okhttp.Call getFireStationByAddressCall(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getFireStationByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/firestation/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (travelTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTime", travelTime));
        if (travelTimeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTimeUnit", travelTimeUnit));
        if (travelDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistance", travelDistance));
        if (travelDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistanceUnit", travelDistanceUnit));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (historicTrafficTimeBucket != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "historicTrafficTimeBucket", historicTrafficTimeBucket));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets FireStationResponse
     * Returns the nearest Firestations from an input address.
     * @param address The address to be searched. (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sort the fire stations results by either travel time or travel distance (nearest first). Default sorting is by travel time. (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return FireStations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireStations getFireStationByAddress(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        ApiResponse<FireStations> resp = getFireStationByAddressWithHttpInfo(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket);
        return resp.getData();
    }

    /**
     * Gets FireStationResponse
     * Returns the nearest Firestations from an input address.
     * @param address The address to be searched. (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sort the fire stations results by either travel time or travel distance (nearest first). Default sorting is by travel time. (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return ApiResponse&lt;FireStations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireStations> getFireStationByAddressWithHttpInfo(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        com.squareup.okhttp.Call call = getFireStationByAddressCall(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, null, null);
        Type localVarReturnType = new TypeToken<FireStations>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets FireStationResponse (asynchronously)
     * Returns the nearest Firestations from an input address.
     * @param address The address to be searched. (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sort the fire stations results by either travel time or travel distance (nearest first). Default sorting is by travel time. (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireStationByAddressAsync(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback<FireStations> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireStationByAddressCall(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireStations>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireStationByLocation */
    private com.squareup.okhttp.Call getFireStationByLocationCall(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getFireStationByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getFireStationByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/firestation/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (travelTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTime", travelTime));
        if (travelTimeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTimeUnit", travelTimeUnit));
        if (travelDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistance", travelDistance));
        if (travelDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistanceUnit", travelDistanceUnit));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (historicTrafficTimeBucket != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "historicTrafficTimeBucket", historicTrafficTimeBucket));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets FireStationResponse
     * Returns the nearest Firestations from an input location.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3. The retrieved fire stations are distance ordered from the specified location. Maximum of 5 fire stations can be retrieved. (optional)
     * @param travelTime Maximum travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sorting of fire stations in result by travel time/distance (nearest first from input location). (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return FireStationsLocation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireStationsLocation getFireStationByLocation(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        ApiResponse<FireStationsLocation> resp = getFireStationByLocationWithHttpInfo(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket);
        return resp.getData();
    }

    /**
     * Gets FireStationResponse
     * Returns the nearest Firestations from an input location.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3. The retrieved fire stations are distance ordered from the specified location. Maximum of 5 fire stations can be retrieved. (optional)
     * @param travelTime Maximum travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sorting of fire stations in result by travel time/distance (nearest first from input location). (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return ApiResponse&lt;FireStationsLocation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireStationsLocation> getFireStationByLocationWithHttpInfo(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        com.squareup.okhttp.Call call = getFireStationByLocationCall(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, null, null);
        Type localVarReturnType = new TypeToken<FireStationsLocation>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets FireStationResponse (asynchronously)
     * Returns the nearest Firestations from an input location.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3. The retrieved fire stations are distance ordered from the specified location. Maximum of 5 fire stations can be retrieved. (optional)
     * @param travelTime Maximum travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sorting of fire stations in result by travel time/distance (nearest first from input location). (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireStationByLocationAsync(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback<FireStationsLocation> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireStationByLocationCall(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireStationsLocation>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFloodRiskByAddress */
    private com.squareup.okhttp.Call getFloodRiskByAddressCall(String address, String includeZoneDesc, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getFloodRiskByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/flood/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (includeZoneDesc != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeZoneDesc", includeZoneDesc));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets FloodRiskResponse
     * Returns the Flood Risk data for flood zones based on an address.
     * @param address Free-text Address (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return FloodRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FloodRiskResponse getFloodRiskByAddress(String address, String includeZoneDesc, String includeGeometry) throws ApiException {
        ApiResponse<FloodRiskResponse> resp = getFloodRiskByAddressWithHttpInfo(address, includeZoneDesc, includeGeometry);
        return resp.getData();
    }

    /**
     * Gets FloodRiskResponse
     * Returns the Flood Risk data for flood zones based on an address.
     * @param address Free-text Address (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;FloodRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FloodRiskResponse> getFloodRiskByAddressWithHttpInfo(String address, String includeZoneDesc, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getFloodRiskByAddressCall(address, includeZoneDesc, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<FloodRiskResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets FloodRiskResponse (asynchronously)
     * Returns the Flood Risk data for flood zones based on an address.
     * @param address Free-text Address (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFloodRiskByAddressAsync(String address, String includeZoneDesc, String includeGeometry, final ApiCallback<FloodRiskResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFloodRiskByAddressCall(address, includeZoneDesc, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FloodRiskResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFloodRiskByAddressBatch */
    private com.squareup.okhttp.Call getFloodRiskByAddressBatchCall(FloodRiskByAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/flood/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting flood risk by address
     * Batch method for getting flood risk by address
     * @param body  (optional)
     * @return FloodRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FloodRiskResponseList getFloodRiskByAddressBatch(FloodRiskByAddressRequest body) throws ApiException {
        ApiResponse<FloodRiskResponseList> resp = getFloodRiskByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting flood risk by address
     * Batch method for getting flood risk by address
     * @param body  (optional)
     * @return ApiResponse&lt;FloodRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FloodRiskResponseList> getFloodRiskByAddressBatchWithHttpInfo(FloodRiskByAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getFloodRiskByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<FloodRiskResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting flood risk by address (asynchronously)
     * Batch method for getting flood risk by address
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFloodRiskByAddressBatchAsync(FloodRiskByAddressRequest body, final ApiCallback<FloodRiskResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFloodRiskByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FloodRiskResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFloodRiskByLocation */
    private com.squareup.okhttp.Call getFloodRiskByLocationCall(String longitude, String latitude, String includeZoneDesc, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getFloodRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getFloodRiskByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/georisk/v1/flood/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (includeZoneDesc != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeZoneDesc", includeZoneDesc));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets FloodRiskResponse
     * Returns the Flood Risk data for Flood Zones and Base Flood Elevation, based on location.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. Default: &#39;Y&#39; (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return FloodRiskLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FloodRiskLocationResponse getFloodRiskByLocation(String longitude, String latitude, String includeZoneDesc, String includeGeometry) throws ApiException {
        ApiResponse<FloodRiskLocationResponse> resp = getFloodRiskByLocationWithHttpInfo(longitude, latitude, includeZoneDesc, includeGeometry);
        return resp.getData();
    }

    /**
     * Gets FloodRiskResponse
     * Returns the Flood Risk data for Flood Zones and Base Flood Elevation, based on location.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. Default: &#39;Y&#39; (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;FloodRiskLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FloodRiskLocationResponse> getFloodRiskByLocationWithHttpInfo(String longitude, String latitude, String includeZoneDesc, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getFloodRiskByLocationCall(longitude, latitude, includeZoneDesc, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<FloodRiskLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets FloodRiskResponse (asynchronously)
     * Returns the Flood Risk data for Flood Zones and Base Flood Elevation, based on location.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. Default: &#39;Y&#39; (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFloodRiskByLocationAsync(String longitude, String latitude, String includeZoneDesc, String includeGeometry, final ApiCallback<FloodRiskLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFloodRiskByLocationCall(longitude, latitude, includeZoneDesc, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FloodRiskLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFloodRiskByLocationBatch */
    private com.squareup.okhttp.Call getFloodRiskByLocationBatchCall(FloodRiskByLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/georisk/v1/flood/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Batch method for getting flood risk by location
     * Batch method for getting flood risk by location
     * @param body  (optional)
     * @return FloodRiskLocationResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FloodRiskLocationResponseList getFloodRiskByLocationBatch(FloodRiskByLocationRequest body) throws ApiException {
        ApiResponse<FloodRiskLocationResponseList> resp = getFloodRiskByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Batch method for getting flood risk by location
     * Batch method for getting flood risk by location
     * @param body  (optional)
     * @return ApiResponse&lt;FloodRiskLocationResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FloodRiskLocationResponseList> getFloodRiskByLocationBatchWithHttpInfo(FloodRiskByLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getFloodRiskByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<FloodRiskLocationResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Batch method for getting flood risk by location (asynchronously)
     * Batch method for getting flood risk by location
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFloodRiskByLocationBatchAsync(FloodRiskByLocationRequest body, final ApiCallback<FloodRiskLocationResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFloodRiskByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FloodRiskLocationResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
