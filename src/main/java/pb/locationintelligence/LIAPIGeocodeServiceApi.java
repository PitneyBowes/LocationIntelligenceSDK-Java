/**
 * Location Intelligence APIs
 * Incorporate our extensive geodata into everyday applications, business processes and workflows.
 *
 * OpenAPI spec version: 3.7.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package pb.locationintelligence;

import pb.ApiCallback;
import pb.ApiClient;
import pb.ApiException;
import pb.ApiResponse;
import pb.Configuration;
import pb.Pair;
import pb.ProgressRequestBody;
import pb.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import pb.locationintelligence.model.GeocodeServiceResponse;
import pb.locationintelligence.model.GeocodeRequest;
import pb.locationintelligence.model.GeocodeServiceResponseList;
import pb.locationintelligence.model.GeocodeCapabilitiesResponse;
import pb.locationintelligence.model.ConfiguredDictionaryResponse;
import pb.locationintelligence.model.PBKeyResponse;
import pb.locationintelligence.model.PBKeyAddressRequest;
import pb.locationintelligence.model.PBKeyResponseList;
import pb.locationintelligence.model.ReverseGeocodeRequest;
import java.math.BigDecimal;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LIAPIGeocodeServiceApi {
    private ApiClient apiClient;

    public LIAPIGeocodeServiceApi() {
        this(Configuration.getDefaultApiClient());
    }

    public LIAPIGeocodeServiceApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for geocode */
    private com.squareup.okhttp.Call geocodeCall(String datapackBundle, String country, String placeName, String mainAddress, String lastLine, String areaName1, String areaName2, String areaName3, String areaName4, Integer postalCode, String matchMode, Boolean fallbackGeo, Boolean fallbackPostal, Integer maxCands, Integer streetOffset, String streetOffsetUnits, Integer cornerOffset, String cornerOffsetUnits, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'datapackBundle' is set
        if (datapackBundle == null) {
            throw new ApiException("Missing the required parameter 'datapackBundle' when calling geocode(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geocode-service/v1/transient/{datapackBundle}/geocode".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "datapackBundle" + "\\}", apiClient.escapeString(datapackBundle.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (country != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "country", country));
        if (placeName != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "placeName", placeName));
        if (mainAddress != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "mainAddress", mainAddress));
        if (lastLine != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "lastLine", lastLine));
        if (areaName1 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "areaName1", areaName1));
        if (areaName2 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "areaName2", areaName2));
        if (areaName3 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "areaName3", areaName3));
        if (areaName4 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "areaName4", areaName4));
        if (postalCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "postalCode", postalCode));
        if (matchMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "matchMode", matchMode));
        if (fallbackGeo != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "fallbackGeo", fallbackGeo));
        if (fallbackPostal != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "fallbackPostal", fallbackPostal));
        if (maxCands != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCands", maxCands));
        if (streetOffset != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "streetOffset", streetOffset));
        if (streetOffsetUnits != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "streetOffsetUnits", streetOffsetUnits));
        if (cornerOffset != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "cornerOffset", cornerOffset));
        if (cornerOffsetUnits != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "cornerOffsetUnits", cornerOffsetUnits));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets Geocode
     * Gets Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param country Country name or ISO code. (optional, default to USA)
     * @param placeName Building name, place name, Point of Interest (POI), company or firm name associated with the input address. (optional)
     * @param mainAddress Single line input, treated as collection of field elements. (optional, default to 4750 Walnut St., Boulder CO, 80301)
     * @param lastLine The last line of the address. (optional)
     * @param areaName1 Specifies the largest geographic area, typically a state or province. (optional)
     * @param areaName2 Specifies the secondary geographic area, typically a county or district. (optional)
     * @param areaName3 Specifies a city or town name. (optional)
     * @param areaName4 Specifies a city subdivision or locality. (optional)
     * @param postalCode The postal code in the appropriate format for the country. (optional)
     * @param matchMode Match modes determine the leniency used to make a match between the input address and the reference data. (optional, default to Standard)
     * @param fallbackGeo Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined. (optional, default to true)
     * @param fallbackPostal Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined. (optional, default to true)
     * @param maxCands The maximum number of candidates to return. Must be an integer value. (optional, default to 1)
     * @param streetOffset Indicates the offset distance from the street segments to use in street-level geocoding. (optional, default to 7)
     * @param streetOffsetUnits Specifies the unit of measurement for the street offset. (optional, default to METERS)
     * @param cornerOffset Specifies the distance to offset the street end points in street-level matching. (optional, default to 7)
     * @param cornerOffsetUnits Specifies the unit of measurement for the corner offset. (optional, default to METERS)
     * @return GeocodeServiceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeocodeServiceResponse geocode(String datapackBundle, String country, String placeName, String mainAddress, String lastLine, String areaName1, String areaName2, String areaName3, String areaName4, Integer postalCode, String matchMode, Boolean fallbackGeo, Boolean fallbackPostal, Integer maxCands, Integer streetOffset, String streetOffsetUnits, Integer cornerOffset, String cornerOffsetUnits) throws ApiException {
        ApiResponse<GeocodeServiceResponse> resp = geocodeWithHttpInfo(datapackBundle, country, placeName, mainAddress, lastLine, areaName1, areaName2, areaName3, areaName4, postalCode, matchMode, fallbackGeo, fallbackPostal, maxCands, streetOffset, streetOffsetUnits, cornerOffset, cornerOffsetUnits);
        return resp.getData();
    }

    /**
     * Gets Geocode
     * Gets Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param country Country name or ISO code. (optional, default to USA)
     * @param placeName Building name, place name, Point of Interest (POI), company or firm name associated with the input address. (optional)
     * @param mainAddress Single line input, treated as collection of field elements. (optional, default to 4750 Walnut St., Boulder CO, 80301)
     * @param lastLine The last line of the address. (optional)
     * @param areaName1 Specifies the largest geographic area, typically a state or province. (optional)
     * @param areaName2 Specifies the secondary geographic area, typically a county or district. (optional)
     * @param areaName3 Specifies a city or town name. (optional)
     * @param areaName4 Specifies a city subdivision or locality. (optional)
     * @param postalCode The postal code in the appropriate format for the country. (optional)
     * @param matchMode Match modes determine the leniency used to make a match between the input address and the reference data. (optional, default to Standard)
     * @param fallbackGeo Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined. (optional, default to true)
     * @param fallbackPostal Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined. (optional, default to true)
     * @param maxCands The maximum number of candidates to return. Must be an integer value. (optional, default to 1)
     * @param streetOffset Indicates the offset distance from the street segments to use in street-level geocoding. (optional, default to 7)
     * @param streetOffsetUnits Specifies the unit of measurement for the street offset. (optional, default to METERS)
     * @param cornerOffset Specifies the distance to offset the street end points in street-level matching. (optional, default to 7)
     * @param cornerOffsetUnits Specifies the unit of measurement for the corner offset. (optional, default to METERS)
     * @return ApiResponse&lt;GeocodeServiceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeocodeServiceResponse> geocodeWithHttpInfo(String datapackBundle, String country, String placeName, String mainAddress, String lastLine, String areaName1, String areaName2, String areaName3, String areaName4, Integer postalCode, String matchMode, Boolean fallbackGeo, Boolean fallbackPostal, Integer maxCands, Integer streetOffset, String streetOffsetUnits, Integer cornerOffset, String cornerOffsetUnits) throws ApiException {
        com.squareup.okhttp.Call call = geocodeCall(datapackBundle, country, placeName, mainAddress, lastLine, areaName1, areaName2, areaName3, areaName4, postalCode, matchMode, fallbackGeo, fallbackPostal, maxCands, streetOffset, streetOffsetUnits, cornerOffset, cornerOffsetUnits, null, null);
        Type localVarReturnType = new TypeToken<GeocodeServiceResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets Geocode (asynchronously)
     * Gets Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param country Country name or ISO code. (optional, default to USA)
     * @param placeName Building name, place name, Point of Interest (POI), company or firm name associated with the input address. (optional)
     * @param mainAddress Single line input, treated as collection of field elements. (optional, default to 4750 Walnut St., Boulder CO, 80301)
     * @param lastLine The last line of the address. (optional)
     * @param areaName1 Specifies the largest geographic area, typically a state or province. (optional)
     * @param areaName2 Specifies the secondary geographic area, typically a county or district. (optional)
     * @param areaName3 Specifies a city or town name. (optional)
     * @param areaName4 Specifies a city subdivision or locality. (optional)
     * @param postalCode The postal code in the appropriate format for the country. (optional)
     * @param matchMode Match modes determine the leniency used to make a match between the input address and the reference data. (optional, default to Standard)
     * @param fallbackGeo Specifies whether to attempt to determine a geographic region centroid when an address-level geocode cannot be determined. (optional, default to true)
     * @param fallbackPostal Specifies whether to attempt to determine a post code centroid when an address-level geocode cannot be determined. (optional, default to true)
     * @param maxCands The maximum number of candidates to return. Must be an integer value. (optional, default to 1)
     * @param streetOffset Indicates the offset distance from the street segments to use in street-level geocoding. (optional, default to 7)
     * @param streetOffsetUnits Specifies the unit of measurement for the street offset. (optional, default to METERS)
     * @param cornerOffset Specifies the distance to offset the street end points in street-level matching. (optional, default to 7)
     * @param cornerOffsetUnits Specifies the unit of measurement for the corner offset. (optional, default to METERS)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call geocodeAsync(String datapackBundle, String country, String placeName, String mainAddress, String lastLine, String areaName1, String areaName2, String areaName3, String areaName4, Integer postalCode, String matchMode, Boolean fallbackGeo, Boolean fallbackPostal, Integer maxCands, Integer streetOffset, String streetOffsetUnits, Integer cornerOffset, String cornerOffsetUnits, final ApiCallback<GeocodeServiceResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = geocodeCall(datapackBundle, country, placeName, mainAddress, lastLine, areaName1, areaName2, areaName3, areaName4, postalCode, matchMode, fallbackGeo, fallbackPostal, maxCands, streetOffset, streetOffsetUnits, cornerOffset, cornerOffsetUnits, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeocodeServiceResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for geocodeBatch */
    private com.squareup.okhttp.Call geocodeBatchCall(String datapackBundle, GeocodeRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // verify the required parameter 'datapackBundle' is set
        if (datapackBundle == null) {
            throw new ApiException("Missing the required parameter 'datapackBundle' when calling geocodeBatch(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geocode-service/v1/transient/{datapackBundle}/geocode".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "datapackBundle" + "\\}", apiClient.escapeString(datapackBundle.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets Geocode
     * Gets Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param body Geocode Request Object (optional)
     * @return GeocodeServiceResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeocodeServiceResponseList geocodeBatch(String datapackBundle, GeocodeRequest body) throws ApiException {
        ApiResponse<GeocodeServiceResponseList> resp = geocodeBatchWithHttpInfo(datapackBundle, body);
        return resp.getData();
    }

    /**
     * Gets Geocode
     * Gets Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param body Geocode Request Object (optional)
     * @return ApiResponse&lt;GeocodeServiceResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeocodeServiceResponseList> geocodeBatchWithHttpInfo(String datapackBundle, GeocodeRequest body) throws ApiException {
        com.squareup.okhttp.Call call = geocodeBatchCall(datapackBundle, body, null, null);
        Type localVarReturnType = new TypeToken<GeocodeServiceResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets Geocode (asynchronously)
     * Gets Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param body Geocode Request Object (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call geocodeBatchAsync(String datapackBundle, GeocodeRequest body, final ApiCallback<GeocodeServiceResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = geocodeBatchCall(datapackBundle, body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeocodeServiceResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getCapabilities */
    private com.squareup.okhttp.Call getCapabilitiesCall(String datapackBundle, String operation, String country, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'datapackBundle' is set
        if (datapackBundle == null) {
            throw new ApiException("Missing the required parameter 'datapackBundle' when calling getCapabilities(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geocode-service/v1/transient/{datapackBundle}/capabilities".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "datapackBundle" + "\\}", apiClient.escapeString(datapackBundle.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (operation != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "operation", operation));
        if (country != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "country", country));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets Capabilities
     * Gets Capabilities
     * @param datapackBundle value of datapackBundle (required)
     * @param operation Geocode or ReverseGeocode Operation. (optional, default to geocode)
     * @param country Country name or ISO code. (optional, default to USA)
     * @return GeocodeCapabilitiesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeocodeCapabilitiesResponse getCapabilities(String datapackBundle, String operation, String country) throws ApiException {
        ApiResponse<GeocodeCapabilitiesResponse> resp = getCapabilitiesWithHttpInfo(datapackBundle, operation, country);
        return resp.getData();
    }

    /**
     * Gets Capabilities
     * Gets Capabilities
     * @param datapackBundle value of datapackBundle (required)
     * @param operation Geocode or ReverseGeocode Operation. (optional, default to geocode)
     * @param country Country name or ISO code. (optional, default to USA)
     * @return ApiResponse&lt;GeocodeCapabilitiesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeocodeCapabilitiesResponse> getCapabilitiesWithHttpInfo(String datapackBundle, String operation, String country) throws ApiException {
        com.squareup.okhttp.Call call = getCapabilitiesCall(datapackBundle, operation, country, null, null);
        Type localVarReturnType = new TypeToken<GeocodeCapabilitiesResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets Capabilities (asynchronously)
     * Gets Capabilities
     * @param datapackBundle value of datapackBundle (required)
     * @param operation Geocode or ReverseGeocode Operation. (optional, default to geocode)
     * @param country Country name or ISO code. (optional, default to USA)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCapabilitiesAsync(String datapackBundle, String operation, String country, final ApiCallback<GeocodeCapabilitiesResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCapabilitiesCall(datapackBundle, operation, country, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeocodeCapabilitiesResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getDictionaries */
    private com.squareup.okhttp.Call getDictionariesCall(String datapackBundle, String country, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'datapackBundle' is set
        if (datapackBundle == null) {
            throw new ApiException("Missing the required parameter 'datapackBundle' when calling getDictionaries(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geocode-service/v1/transient/{datapackBundle}/dictionaries".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "datapackBundle" + "\\}", apiClient.escapeString(datapackBundle.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (country != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "country", country));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets installed Dictionaries
     * Gets installed Dictionaries
     * @param datapackBundle value of datapackBundle (required)
     * @param country Three Letter ISO Country code (optional, default to USA)
     * @return ConfiguredDictionaryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ConfiguredDictionaryResponse getDictionaries(String datapackBundle, String country) throws ApiException {
        ApiResponse<ConfiguredDictionaryResponse> resp = getDictionariesWithHttpInfo(datapackBundle, country);
        return resp.getData();
    }

    /**
     * Gets installed Dictionaries
     * Gets installed Dictionaries
     * @param datapackBundle value of datapackBundle (required)
     * @param country Three Letter ISO Country code (optional, default to USA)
     * @return ApiResponse&lt;ConfiguredDictionaryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ConfiguredDictionaryResponse> getDictionariesWithHttpInfo(String datapackBundle, String country) throws ApiException {
        com.squareup.okhttp.Call call = getDictionariesCall(datapackBundle, country, null, null);
        Type localVarReturnType = new TypeToken<ConfiguredDictionaryResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets installed Dictionaries (asynchronously)
     * Gets installed Dictionaries
     * @param datapackBundle value of datapackBundle (required)
     * @param country Three Letter ISO Country code (optional, default to USA)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getDictionariesAsync(String datapackBundle, String country, final ApiCallback<ConfiguredDictionaryResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getDictionariesCall(datapackBundle, country, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ConfiguredDictionaryResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getPBKey */
    private com.squareup.okhttp.Call getPBKeyCall(String address, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getPBKey(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geocode-service/v1/key/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets PBKey
     * Gets PBKey for an input free form address text
     * @param address free form address text (required)
     * @return PBKeyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PBKeyResponse getPBKey(String address) throws ApiException {
        ApiResponse<PBKeyResponse> resp = getPBKeyWithHttpInfo(address);
        return resp.getData();
    }

    /**
     * Gets PBKey
     * Gets PBKey for an input free form address text
     * @param address free form address text (required)
     * @return ApiResponse&lt;PBKeyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PBKeyResponse> getPBKeyWithHttpInfo(String address) throws ApiException {
        com.squareup.okhttp.Call call = getPBKeyCall(address, null, null);
        Type localVarReturnType = new TypeToken<PBKeyResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets PBKey (asynchronously)
     * Gets PBKey for an input free form address text
     * @param address free form address text (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getPBKeyAsync(String address, final ApiCallback<PBKeyResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getPBKeyCall(address, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PBKeyResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getPBKeys */
    private com.squareup.okhttp.Call getPBKeysCall(PBKeyAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/geocode-service/v1/key/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Gets PBKeys
     * Gets PBKeys for multiple input addresses
     * @param body  (optional)
     * @return PBKeyResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PBKeyResponseList getPBKeys(PBKeyAddressRequest body) throws ApiException {
        ApiResponse<PBKeyResponseList> resp = getPBKeysWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Gets PBKeys
     * Gets PBKeys for multiple input addresses
     * @param body  (optional)
     * @return ApiResponse&lt;PBKeyResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PBKeyResponseList> getPBKeysWithHttpInfo(PBKeyAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getPBKeysCall(body, null, null);
        Type localVarReturnType = new TypeToken<PBKeyResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets PBKeys (asynchronously)
     * Gets PBKeys for multiple input addresses
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getPBKeysAsync(PBKeyAddressRequest body, final ApiCallback<PBKeyResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getPBKeysCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PBKeyResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for reverseGeocodBatch */
    private com.squareup.okhttp.Call reverseGeocodBatchCall(String datapackBundle, ReverseGeocodeRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // verify the required parameter 'datapackBundle' is set
        if (datapackBundle == null) {
            throw new ApiException("Missing the required parameter 'datapackBundle' when calling reverseGeocodBatch(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geocode-service/v1/transient/{datapackBundle}/reverseGeocode".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "datapackBundle" + "\\}", apiClient.escapeString(datapackBundle.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * reverse Geocode
     * reverse Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param body Reverse Geocode Request object (optional)
     * @return GeocodeServiceResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeocodeServiceResponseList reverseGeocodBatch(String datapackBundle, ReverseGeocodeRequest body) throws ApiException {
        ApiResponse<GeocodeServiceResponseList> resp = reverseGeocodBatchWithHttpInfo(datapackBundle, body);
        return resp.getData();
    }

    /**
     * reverse Geocode
     * reverse Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param body Reverse Geocode Request object (optional)
     * @return ApiResponse&lt;GeocodeServiceResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeocodeServiceResponseList> reverseGeocodBatchWithHttpInfo(String datapackBundle, ReverseGeocodeRequest body) throws ApiException {
        com.squareup.okhttp.Call call = reverseGeocodBatchCall(datapackBundle, body, null, null);
        Type localVarReturnType = new TypeToken<GeocodeServiceResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * reverse Geocode (asynchronously)
     * reverse Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param body Reverse Geocode Request object (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call reverseGeocodBatchAsync(String datapackBundle, ReverseGeocodeRequest body, final ApiCallback<GeocodeServiceResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = reverseGeocodBatchCall(datapackBundle, body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeocodeServiceResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for reverseGeocode */
    private com.squareup.okhttp.Call reverseGeocodeCall(String datapackBundle, BigDecimal x, BigDecimal y, String country, String coordSysName, Integer distance, String distanceUnits, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'datapackBundle' is set
        if (datapackBundle == null) {
            throw new ApiException("Missing the required parameter 'datapackBundle' when calling reverseGeocode(Async)");
        }
        
        // verify the required parameter 'x' is set
        if (x == null) {
            throw new ApiException("Missing the required parameter 'x' when calling reverseGeocode(Async)");
        }
        
        // verify the required parameter 'y' is set
        if (y == null) {
            throw new ApiException("Missing the required parameter 'y' when calling reverseGeocode(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geocode-service/v1/transient/{datapackBundle}/reverseGeocode".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "datapackBundle" + "\\}", apiClient.escapeString(datapackBundle.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (x != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "x", x));
        if (y != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "y", y));
        if (country != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "country", country));
        if (coordSysName != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "coordSysName", coordSysName));
        if (distance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "distance", distance));
        if (distanceUnits != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "distanceUnits", distanceUnits));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * reverse Geocode
     * reverse Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param x Longitude of the location. (required)
     * @param y Latitude of the location. (required)
     * @param country Country name or ISO code. (optional)
     * @param coordSysName Coordinate system to convert geometry in format codespace:code. (optional, default to EPSG:4326)
     * @param distance Radius in which search is performed. (optional, default to 150)
     * @param distanceUnits Unit of measurement for the search distance. (optional, default to METERS)
     * @return GeocodeServiceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeocodeServiceResponse reverseGeocode(String datapackBundle, BigDecimal x, BigDecimal y, String country, String coordSysName, Integer distance, String distanceUnits) throws ApiException {
        ApiResponse<GeocodeServiceResponse> resp = reverseGeocodeWithHttpInfo(datapackBundle, x, y, country, coordSysName, distance, distanceUnits);
        return resp.getData();
    }

    /**
     * reverse Geocode
     * reverse Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param x Longitude of the location. (required)
     * @param y Latitude of the location. (required)
     * @param country Country name or ISO code. (optional)
     * @param coordSysName Coordinate system to convert geometry in format codespace:code. (optional, default to EPSG:4326)
     * @param distance Radius in which search is performed. (optional, default to 150)
     * @param distanceUnits Unit of measurement for the search distance. (optional, default to METERS)
     * @return ApiResponse&lt;GeocodeServiceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeocodeServiceResponse> reverseGeocodeWithHttpInfo(String datapackBundle, BigDecimal x, BigDecimal y, String country, String coordSysName, Integer distance, String distanceUnits) throws ApiException {
        com.squareup.okhttp.Call call = reverseGeocodeCall(datapackBundle, x, y, country, coordSysName, distance, distanceUnits, null, null);
        Type localVarReturnType = new TypeToken<GeocodeServiceResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * reverse Geocode (asynchronously)
     * reverse Geocode
     * @param datapackBundle value of datapackBundle (required)
     * @param x Longitude of the location. (required)
     * @param y Latitude of the location. (required)
     * @param country Country name or ISO code. (optional)
     * @param coordSysName Coordinate system to convert geometry in format codespace:code. (optional, default to EPSG:4326)
     * @param distance Radius in which search is performed. (optional, default to 150)
     * @param distanceUnits Unit of measurement for the search distance. (optional, default to METERS)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call reverseGeocodeAsync(String datapackBundle, BigDecimal x, BigDecimal y, String country, String coordSysName, Integer distance, String distanceUnits, final ApiCallback<GeocodeServiceResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = reverseGeocodeCall(datapackBundle, x, y, country, coordSysName, distance, distanceUnits, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeocodeServiceResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
