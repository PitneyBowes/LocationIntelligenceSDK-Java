/**
 * Location Intelligence APIs
 * Incorporate our extensive geodata into everyday applications, business processes and workflows.
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package pb.locationintelligence;

import pb.ApiCallback;
import pb.ApiClient;
import pb.ApiException;
import pb.ApiResponse;
import pb.Configuration;
import pb.Pair;
import pb.ProgressRequestBody;
import pb.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import pb.locationintelligence.model.Locations;
import pb.locationintelligence.model.PlaceByLocations;
import pb.locationintelligence.model.Timezone;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LIAPIGeoEnhanceServiceApi {
    private ApiClient apiClient;

    public LIAPIGeoEnhanceServiceApi() {
        this(Configuration.getDefaultApiClient());
    }

    public LIAPIGeoEnhanceServiceApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for getAddress */
    private com.squareup.okhttp.Call getAddressCall(String latitude, String longitude, String searchRadius, String searchRadiusUnit, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getAddress(Async)");
        }
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geoenhance/v1/address/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (searchRadius != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadius", searchRadius));
        if (searchRadiusUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadiusUnit", searchRadiusUnit));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Address By Location.
     * This service accepts longitude and latitude as input and returns an address for that location.
     * @param latitude Latitude of the location. (required)
     * @param longitude Longitude of the location. (required)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as feet, kilometers, miles or meters. (optional)
     * @return Locations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Locations getAddress(String latitude, String longitude, String searchRadius, String searchRadiusUnit) throws ApiException {
        ApiResponse<Locations> resp = getAddressWithHttpInfo(latitude, longitude, searchRadius, searchRadiusUnit);
        return resp.getData();
    }

    /**
     * Address By Location.
     * This service accepts longitude and latitude as input and returns an address for that location.
     * @param latitude Latitude of the location. (required)
     * @param longitude Longitude of the location. (required)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as feet, kilometers, miles or meters. (optional)
     * @return ApiResponse&lt;Locations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Locations> getAddressWithHttpInfo(String latitude, String longitude, String searchRadius, String searchRadiusUnit) throws ApiException {
        com.squareup.okhttp.Call call = getAddressCall(latitude, longitude, searchRadius, searchRadiusUnit, null, null);
        Type localVarReturnType = new TypeToken<Locations>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Address By Location. (asynchronously)
     * This service accepts longitude and latitude as input and returns an address for that location.
     * @param latitude Latitude of the location. (required)
     * @param longitude Longitude of the location. (required)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as feet, kilometers, miles or meters. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getAddressAsync(String latitude, String longitude, String searchRadius, String searchRadiusUnit, final ApiCallback<Locations> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getAddressCall(latitude, longitude, searchRadius, searchRadiusUnit, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Locations>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEntityByLocation */
    private com.squareup.okhttp.Call getEntityByLocationCall(String longitude, String latitude, String brandName, String category, String maxCandidates, String searchRadius, String searchRadiusUnit, String searchDataset, String searchPriority, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String mode, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getEntityByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getEntityByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geoenhance/v1/poi/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (brandName != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "brandName", brandName));
        if (category != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "category", category));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (searchRadius != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadius", searchRadius));
        if (searchRadiusUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadiusUnit", searchRadiusUnit));
        if (searchDataset != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchDataset", searchDataset));
        if (searchPriority != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchPriority", searchPriority));
        if (travelTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTime", travelTime));
        if (travelTimeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTimeUnit", travelTimeUnit));
        if (travelDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistance", travelDistance));
        if (travelDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistanceUnit", travelDistanceUnit));
        if (mode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "mode", mode));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Points Of Interest By Location.
     * Identifies and retrieves Points of Interest that exist around a specific location (ordered by distance from the location).
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param brandName Specifies the name of the brand to be searched. Also performs search on partially specified brand names. (optional)
     * @param category Specific Category/Categories for which the POI search is performed. (Categories 10020102,10020103 are for Chinese and Italian Restaurants .https://developer2.pitneybowes.com/docs/location-intelligence/v1/en/poicategory/EightDigitPOICategoryCodes.xlsx  (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param searchDataset The datasets upon which the POI search can be performed. (optional)
     * @param searchPriority Search order of POI datasets mentioned in searchDataset. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param mode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time.Allowed values driving and walking (optional)
     * @return Locations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Locations getEntityByLocation(String longitude, String latitude, String brandName, String category, String maxCandidates, String searchRadius, String searchRadiusUnit, String searchDataset, String searchPriority, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String mode) throws ApiException {
        ApiResponse<Locations> resp = getEntityByLocationWithHttpInfo(longitude, latitude, brandName, category, maxCandidates, searchRadius, searchRadiusUnit, searchDataset, searchPriority, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, mode);
        return resp.getData();
    }

    /**
     * Points Of Interest By Location.
     * Identifies and retrieves Points of Interest that exist around a specific location (ordered by distance from the location).
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param brandName Specifies the name of the brand to be searched. Also performs search on partially specified brand names. (optional)
     * @param category Specific Category/Categories for which the POI search is performed. (Categories 10020102,10020103 are for Chinese and Italian Restaurants .https://developer2.pitneybowes.com/docs/location-intelligence/v1/en/poicategory/EightDigitPOICategoryCodes.xlsx  (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param searchDataset The datasets upon which the POI search can be performed. (optional)
     * @param searchPriority Search order of POI datasets mentioned in searchDataset. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param mode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time.Allowed values driving and walking (optional)
     * @return ApiResponse&lt;Locations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Locations> getEntityByLocationWithHttpInfo(String longitude, String latitude, String brandName, String category, String maxCandidates, String searchRadius, String searchRadiusUnit, String searchDataset, String searchPriority, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String mode) throws ApiException {
        com.squareup.okhttp.Call call = getEntityByLocationCall(longitude, latitude, brandName, category, maxCandidates, searchRadius, searchRadiusUnit, searchDataset, searchPriority, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, mode, null, null);
        Type localVarReturnType = new TypeToken<Locations>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Points Of Interest By Location. (asynchronously)
     * Identifies and retrieves Points of Interest that exist around a specific location (ordered by distance from the location).
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param brandName Specifies the name of the brand to be searched. Also performs search on partially specified brand names. (optional)
     * @param category Specific Category/Categories for which the POI search is performed. (Categories 10020102,10020103 are for Chinese and Italian Restaurants .https://developer2.pitneybowes.com/docs/location-intelligence/v1/en/poicategory/EightDigitPOICategoryCodes.xlsx  (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param searchDataset The datasets upon which the POI search can be performed. (optional)
     * @param searchPriority Search order of POI datasets mentioned in searchDataset. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param mode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time.Allowed values driving and walking (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEntityByLocationAsync(String longitude, String latitude, String brandName, String category, String maxCandidates, String searchRadius, String searchRadiusUnit, String searchDataset, String searchPriority, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String mode, final ApiCallback<Locations> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEntityByLocationCall(longitude, latitude, brandName, category, maxCandidates, searchRadius, searchRadiusUnit, searchDataset, searchPriority, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, mode, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Locations>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getPlaceByLocation */
    private com.squareup.okhttp.Call getPlaceByLocationCall(String longitude, String latitude, String levelHint, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getPlaceByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getPlaceByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geoenhance/v1/place/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (levelHint != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "levelHint", levelHint));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Place By Location.
     * Identifies and retrieves the nearest neighborhood around a specific location. This GeoEnhance service accepts latitude &amp; longitude as input and returns a place name.
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param levelHint Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6 (optional)
     * @return PlaceByLocations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PlaceByLocations getPlaceByLocation(String longitude, String latitude, String levelHint) throws ApiException {
        ApiResponse<PlaceByLocations> resp = getPlaceByLocationWithHttpInfo(longitude, latitude, levelHint);
        return resp.getData();
    }

    /**
     * Place By Location.
     * Identifies and retrieves the nearest neighborhood around a specific location. This GeoEnhance service accepts latitude &amp; longitude as input and returns a place name.
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param levelHint Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6 (optional)
     * @return ApiResponse&lt;PlaceByLocations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PlaceByLocations> getPlaceByLocationWithHttpInfo(String longitude, String latitude, String levelHint) throws ApiException {
        com.squareup.okhttp.Call call = getPlaceByLocationCall(longitude, latitude, levelHint, null, null);
        Type localVarReturnType = new TypeToken<PlaceByLocations>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Place By Location. (asynchronously)
     * Identifies and retrieves the nearest neighborhood around a specific location. This GeoEnhance service accepts latitude &amp; longitude as input and returns a place name.
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param levelHint Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6 (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getPlaceByLocationAsync(String longitude, String latitude, String levelHint, final ApiCallback<PlaceByLocations> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getPlaceByLocationCall(longitude, latitude, levelHint, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PlaceByLocations>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getTimezoneByLocation */
    private com.squareup.okhttp.Call getTimezoneByLocationCall(String timestamp, String longitude, String latitude, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'timestamp' is set
        if (timestamp == null) {
            throw new ApiException("Missing the required parameter 'timestamp' when calling getTimezoneByLocation(Async)");
        }
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getTimezoneByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getTimezoneByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geoenhance/v1/timezone/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (timestamp != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "timestamp", timestamp));
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Timezone By Location.
     * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
     * @param timestamp Timestamp in miliseconds. (required)
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @return Timezone
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Timezone getTimezoneByLocation(String timestamp, String longitude, String latitude) throws ApiException {
        ApiResponse<Timezone> resp = getTimezoneByLocationWithHttpInfo(timestamp, longitude, latitude);
        return resp.getData();
    }

    /**
     * Timezone By Location.
     * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
     * @param timestamp Timestamp in miliseconds. (required)
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @return ApiResponse&lt;Timezone&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Timezone> getTimezoneByLocationWithHttpInfo(String timestamp, String longitude, String latitude) throws ApiException {
        com.squareup.okhttp.Call call = getTimezoneByLocationCall(timestamp, longitude, latitude, null, null);
        Type localVarReturnType = new TypeToken<Timezone>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Timezone By Location. (asynchronously)
     * Identifies and retrieves the local time of any location in the world for a given latitude, longitude and time. The input and retrieved time format is in milliseconds.
     * @param timestamp Timestamp in miliseconds. (required)
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getTimezoneByLocationAsync(String timestamp, String longitude, String latitude, final ApiCallback<Timezone> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getTimezoneByLocationCall(timestamp, longitude, latitude, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Timezone>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
