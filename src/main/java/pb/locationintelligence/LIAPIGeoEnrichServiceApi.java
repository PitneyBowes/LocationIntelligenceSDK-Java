/**
 * Location Intelligence APIs
 * Incorporate our extensive geodata into everyday applications, business processes and workflows.
 *
 * OpenAPI spec version: 7.5.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package pb.locationintelligence;

import pb.ApiCallback;
import pb.ApiClient;
import pb.ApiException;
import pb.ApiResponse;
import pb.Configuration;
import pb.Pair;
import pb.ProgressRequestBody;
import pb.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import pb.locationintelligence.model.GeoEnrichMetadataResponse;
import pb.locationintelligence.model.POIPlaces;
import pb.locationintelligence.model.GeoEnrichResponse;
import pb.locationintelligence.model.PlaceByLocations;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LIAPIGeoEnrichServiceApi {
    private ApiClient apiClient;

    public LIAPIGeoEnrichServiceApi() {
        this(Configuration.getDefaultApiClient());
    }

    public LIAPIGeoEnrichServiceApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for getCategoryCodeMetadata */
    private com.squareup.okhttp.Call getCategoryCodeMetadataCall(String categoryCode, String level, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        

        // create path and map variables
        String localVarPath = "/geoenrich/v1/metadata/category".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (categoryCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "categoryCode", categoryCode));
        if (level != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "level", level));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml", "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Returns Category Codes with their sub-categories (if exist), descriptions and SIC Codes mapping
     * Accepts first partial digits or full category codes to filter the response
     * @param categoryCode Specify starting digits or full category code to filter the response (optional)
     * @param level Allowed values are 1,2,3. If level&#x3D;1, then only 4 digits category codes will be returned, level&#x3D;2 means only 6 digits category codes   will be returned, level&#x3D;3 means only 11 digits category codes will be returned. Multiple comma-separated values will also be accepted. So level&#x3D;&#39;1,2&#39; means return 4 digits and 6 digits category codes. (optional)
     * @return GeoEnrichMetadataResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeoEnrichMetadataResponse getCategoryCodeMetadata(String categoryCode, String level) throws ApiException {
        ApiResponse<GeoEnrichMetadataResponse> resp = getCategoryCodeMetadataWithHttpInfo(categoryCode, level);
        return resp.getData();
    }

    /**
     * Returns Category Codes with their sub-categories (if exist), descriptions and SIC Codes mapping
     * Accepts first partial digits or full category codes to filter the response
     * @param categoryCode Specify starting digits or full category code to filter the response (optional)
     * @param level Allowed values are 1,2,3. If level&#x3D;1, then only 4 digits category codes will be returned, level&#x3D;2 means only 6 digits category codes   will be returned, level&#x3D;3 means only 11 digits category codes will be returned. Multiple comma-separated values will also be accepted. So level&#x3D;&#39;1,2&#39; means return 4 digits and 6 digits category codes. (optional)
     * @return ApiResponse&lt;GeoEnrichMetadataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeoEnrichMetadataResponse> getCategoryCodeMetadataWithHttpInfo(String categoryCode, String level) throws ApiException {
        com.squareup.okhttp.Call call = getCategoryCodeMetadataCall(categoryCode, level, null, null);
        Type localVarReturnType = new TypeToken<GeoEnrichMetadataResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Returns Category Codes with their sub-categories (if exist), descriptions and SIC Codes mapping (asynchronously)
     * Accepts first partial digits or full category codes to filter the response
     * @param categoryCode Specify starting digits or full category code to filter the response (optional)
     * @param level Allowed values are 1,2,3. If level&#x3D;1, then only 4 digits category codes will be returned, level&#x3D;2 means only 6 digits category codes   will be returned, level&#x3D;3 means only 11 digits category codes will be returned. Multiple comma-separated values will also be accepted. So level&#x3D;&#39;1,2&#39; means return 4 digits and 6 digits category codes. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCategoryCodeMetadataAsync(String categoryCode, String level, final ApiCallback<GeoEnrichMetadataResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCategoryCodeMetadataCall(categoryCode, level, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeoEnrichMetadataResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getPOIById */
    private com.squareup.okhttp.Call getPOIByIdCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getPOIById(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geoenrich/v1/poi/{id}".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Point of Interest By Id.
     * 
     * @param id POI unique Identifier. Accepts only numbers. (required)
     * @return POIPlaces
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public POIPlaces getPOIById(String id) throws ApiException {
        ApiResponse<POIPlaces> resp = getPOIByIdWithHttpInfo(id);
        return resp.getData();
    }

    /**
     * Point of Interest By Id.
     * 
     * @param id POI unique Identifier. Accepts only numbers. (required)
     * @return ApiResponse&lt;POIPlaces&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<POIPlaces> getPOIByIdWithHttpInfo(String id) throws ApiException {
        com.squareup.okhttp.Call call = getPOIByIdCall(id, null, null);
        Type localVarReturnType = new TypeToken<POIPlaces>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Point of Interest By Id. (asynchronously)
     * 
     * @param id POI unique Identifier. Accepts only numbers. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getPOIByIdAsync(String id, final ApiCallback<POIPlaces> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getPOIByIdCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<POIPlaces>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getPOIsByAddress */
    private com.squareup.okhttp.Call getPOIsByAddressCall(String address, String country, String name, String type, String categoryCode, String sicCode, String maxCandidates, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String sortBy, String fuzzyOnName, String page, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getPOIsByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geoenrich/v1/poi/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (country != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "country", country));
        if (name != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "name", name));
        if (type != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
        if (categoryCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "categoryCode", categoryCode));
        if (sicCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sicCode", sicCode));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (searchRadius != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadius", searchRadius));
        if (searchRadiusUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadiusUnit", searchRadiusUnit));
        if (travelTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTime", travelTime));
        if (travelTimeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTimeUnit", travelTimeUnit));
        if (travelDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistance", travelDistance));
        if (travelDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistanceUnit", travelDistanceUnit));
        if (travelMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelMode", travelMode));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (fuzzyOnName != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "fuzzyOnName", fuzzyOnName));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "page", page));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml", "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Points of Interest By Address.
     * Accepts address as an input to retrieve nearby points of interest.
     * @param address Address (required)
     * @param country Country (optional)
     * @param name Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking (optional)
     * @param sortBy Specifies the order in which POIs are retrieved. (optional, default to distance)
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness. (optional)
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned. (optional)
     * @return GeoEnrichResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeoEnrichResponse getPOIsByAddress(String address, String country, String name, String type, String categoryCode, String sicCode, String maxCandidates, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String sortBy, String fuzzyOnName, String page) throws ApiException {
        ApiResponse<GeoEnrichResponse> resp = getPOIsByAddressWithHttpInfo(address, country, name, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page);
        return resp.getData();
    }

    /**
     * Points of Interest By Address.
     * Accepts address as an input to retrieve nearby points of interest.
     * @param address Address (required)
     * @param country Country (optional)
     * @param name Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking (optional)
     * @param sortBy Specifies the order in which POIs are retrieved. (optional, default to distance)
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness. (optional)
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned. (optional)
     * @return ApiResponse&lt;GeoEnrichResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeoEnrichResponse> getPOIsByAddressWithHttpInfo(String address, String country, String name, String type, String categoryCode, String sicCode, String maxCandidates, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String sortBy, String fuzzyOnName, String page) throws ApiException {
        com.squareup.okhttp.Call call = getPOIsByAddressCall(address, country, name, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, null, null);
        Type localVarReturnType = new TypeToken<GeoEnrichResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Points of Interest By Address. (asynchronously)
     * Accepts address as an input to retrieve nearby points of interest.
     * @param address Address (required)
     * @param country Country (optional)
     * @param name Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking (optional)
     * @param sortBy Specifies the order in which POIs are retrieved. (optional, default to distance)
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness. (optional)
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getPOIsByAddressAsync(String address, String country, String name, String type, String categoryCode, String sicCode, String maxCandidates, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String sortBy, String fuzzyOnName, String page, final ApiCallback<GeoEnrichResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getPOIsByAddressCall(address, country, name, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeoEnrichResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getPOIsByArea */
    private com.squareup.okhttp.Call getPOIsByAreaCall(String country, String areaName3, String postcode1, String postcode2, String name, String type, String categoryCode, String sicCode, String maxCandidates, String fuzzyOnName, String page, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'country' is set
        if (country == null) {
            throw new ApiException("Missing the required parameter 'country' when calling getPOIsByArea(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geoenrich/v1/poi/byarea".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (areaName3 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "areaName3", areaName3));
        if (postcode1 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "postcode1", postcode1));
        if (postcode2 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "postcode2", postcode2));
        if (country != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "country", country));
        if (name != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "name", name));
        if (type != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
        if (categoryCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "categoryCode", categoryCode));
        if (sicCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sicCode", sicCode));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (fuzzyOnName != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "fuzzyOnName", fuzzyOnName));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "page", page));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml", "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Points of Interest By Area.
     * Accepts postcode or city as an input to retrieve nearby points of interest.
     * @param country Country (required)
     * @param areaName3 Either areaName3 or postcode is required (optional)
     * @param postcode1 Either areaName3 or postcode is required (optional)
     * @param postcode2 postcode extension (optional)
     * @param name Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness. (optional)
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned. (optional)
     * @return GeoEnrichResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeoEnrichResponse getPOIsByArea(String country, String areaName3, String postcode1, String postcode2, String name, String type, String categoryCode, String sicCode, String maxCandidates, String fuzzyOnName, String page) throws ApiException {
        ApiResponse<GeoEnrichResponse> resp = getPOIsByAreaWithHttpInfo(country, areaName3, postcode1, postcode2, name, type, categoryCode, sicCode, maxCandidates, fuzzyOnName, page);
        return resp.getData();
    }

    /**
     * Points of Interest By Area.
     * Accepts postcode or city as an input to retrieve nearby points of interest.
     * @param country Country (required)
     * @param areaName3 Either areaName3 or postcode is required (optional)
     * @param postcode1 Either areaName3 or postcode is required (optional)
     * @param postcode2 postcode extension (optional)
     * @param name Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness. (optional)
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned. (optional)
     * @return ApiResponse&lt;GeoEnrichResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeoEnrichResponse> getPOIsByAreaWithHttpInfo(String country, String areaName3, String postcode1, String postcode2, String name, String type, String categoryCode, String sicCode, String maxCandidates, String fuzzyOnName, String page) throws ApiException {
        com.squareup.okhttp.Call call = getPOIsByAreaCall(country, areaName3, postcode1, postcode2, name, type, categoryCode, sicCode, maxCandidates, fuzzyOnName, page, null, null);
        Type localVarReturnType = new TypeToken<GeoEnrichResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Points of Interest By Area. (asynchronously)
     * Accepts postcode or city as an input to retrieve nearby points of interest.
     * @param country Country (required)
     * @param areaName3 Either areaName3 or postcode is required (optional)
     * @param postcode1 Either areaName3 or postcode is required (optional)
     * @param postcode2 postcode extension (optional)
     * @param name Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness. (optional)
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getPOIsByAreaAsync(String country, String areaName3, String postcode1, String postcode2, String name, String type, String categoryCode, String sicCode, String maxCandidates, String fuzzyOnName, String page, final ApiCallback<GeoEnrichResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getPOIsByAreaCall(country, areaName3, postcode1, postcode2, name, type, categoryCode, sicCode, maxCandidates, fuzzyOnName, page, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeoEnrichResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getPOIsByLocation */
    private com.squareup.okhttp.Call getPOIsByLocationCall(String longitude, String latitude, String searchText, String type, String categoryCode, String sicCode, String maxCandidates, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String sortBy, String fuzzyOnName, String page, String searchOnNameOnly, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getPOIsByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getPOIsByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geoenrich/v1/poi/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (searchText != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchText", searchText));
        if (type != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
        if (categoryCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "categoryCode", categoryCode));
        if (sicCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sicCode", sicCode));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (searchRadius != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadius", searchRadius));
        if (searchRadiusUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadiusUnit", searchRadiusUnit));
        if (travelTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTime", travelTime));
        if (travelTimeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTimeUnit", travelTimeUnit));
        if (travelDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistance", travelDistance));
        if (travelDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistanceUnit", travelDistanceUnit));
        if (travelMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelMode", travelMode));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (fuzzyOnName != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "fuzzyOnName", fuzzyOnName));
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "page", page));
        if (searchOnNameOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchOnNameOnly", searchOnNameOnly));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml", "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Points of Interest By Location.
     * Accepts longitude and latitude as an input to retrieve nearby points of interest.
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param searchText Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking (optional)
     * @param sortBy Specifies the order in which POIs are retrieved. (optional, default to distance)
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness. (optional)
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned. (optional)
     * @param searchOnNameOnly search name description (optional)
     * @return GeoEnrichResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeoEnrichResponse getPOIsByLocation(String longitude, String latitude, String searchText, String type, String categoryCode, String sicCode, String maxCandidates, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String sortBy, String fuzzyOnName, String page, String searchOnNameOnly) throws ApiException {
        ApiResponse<GeoEnrichResponse> resp = getPOIsByLocationWithHttpInfo(longitude, latitude, searchText, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, searchOnNameOnly);
        return resp.getData();
    }

    /**
     * Points of Interest By Location.
     * Accepts longitude and latitude as an input to retrieve nearby points of interest.
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param searchText Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking (optional)
     * @param sortBy Specifies the order in which POIs are retrieved. (optional, default to distance)
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness. (optional)
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned. (optional)
     * @param searchOnNameOnly search name description (optional)
     * @return ApiResponse&lt;GeoEnrichResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeoEnrichResponse> getPOIsByLocationWithHttpInfo(String longitude, String latitude, String searchText, String type, String categoryCode, String sicCode, String maxCandidates, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String sortBy, String fuzzyOnName, String page, String searchOnNameOnly) throws ApiException {
        com.squareup.okhttp.Call call = getPOIsByLocationCall(longitude, latitude, searchText, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, searchOnNameOnly, null, null);
        Type localVarReturnType = new TypeToken<GeoEnrichResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Points of Interest By Location. (asynchronously)
     * Accepts longitude and latitude as an input to retrieve nearby points of interest.
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param searchText Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking (optional)
     * @param sortBy Specifies the order in which POIs are retrieved. (optional, default to distance)
     * @param fuzzyOnName Allowed values are Y/N. If N, the search on name will not allow fuzziness. (optional)
     * @param page Will support pagination, by default 1st page with maxCandidates results are returned. (optional)
     * @param searchOnNameOnly search name description (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getPOIsByLocationAsync(String longitude, String latitude, String searchText, String type, String categoryCode, String sicCode, String maxCandidates, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String sortBy, String fuzzyOnName, String page, String searchOnNameOnly, final ApiCallback<GeoEnrichResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getPOIsByLocationCall(longitude, latitude, searchText, type, categoryCode, sicCode, maxCandidates, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, sortBy, fuzzyOnName, page, searchOnNameOnly, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeoEnrichResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getPlaceByLocation */
    private com.squareup.okhttp.Call getPlaceByLocationCall(String longitude, String latitude, String levelHint, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getPlaceByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getPlaceByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/geoenrich/v1/place/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (levelHint != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "levelHint", levelHint));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Place By Location.
     * Identifies and retrieves the nearest neighborhood around a specific location. This GeoEnrich service accepts latitude &amp; longitude as input and returns a place name.
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param levelHint Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6 (optional)
     * @return PlaceByLocations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PlaceByLocations getPlaceByLocation(String longitude, String latitude, String levelHint) throws ApiException {
        ApiResponse<PlaceByLocations> resp = getPlaceByLocationWithHttpInfo(longitude, latitude, levelHint);
        return resp.getData();
    }

    /**
     * Place By Location.
     * Identifies and retrieves the nearest neighborhood around a specific location. This GeoEnrich service accepts latitude &amp; longitude as input and returns a place name.
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param levelHint Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6 (optional)
     * @return ApiResponse&lt;PlaceByLocations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PlaceByLocations> getPlaceByLocationWithHttpInfo(String longitude, String latitude, String levelHint) throws ApiException {
        com.squareup.okhttp.Call call = getPlaceByLocationCall(longitude, latitude, levelHint, null, null);
        Type localVarReturnType = new TypeToken<PlaceByLocations>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Place By Location. (asynchronously)
     * Identifies and retrieves the nearest neighborhood around a specific location. This GeoEnrich service accepts latitude &amp; longitude as input and returns a place name.
     * @param longitude Longitude of the location. (required)
     * @param latitude Latitude of the location. (required)
     * @param levelHint Numeric code of geographic hierarchy level which is classified at six levels.Allowed values 1,2,3,4,5,6 (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getPlaceByLocationAsync(String longitude, String latitude, String levelHint, final ApiCallback<PlaceByLocations> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getPlaceByLocationCall(longitude, latitude, levelHint, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PlaceByLocations>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getSICMetadata */
    private com.squareup.okhttp.Call getSICMetadataCall(String sicCode, String level, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        

        // create path and map variables
        String localVarPath = "/geoenrich/v1/metadata/sic".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sicCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sicCode", sicCode));
        if (level != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "level", level));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml", "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Returns SIC Codes with their Industry Titles and Category Codes mapping
     * Accepts first few partial digits or full SIC codes to filter the response
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param level Allowed values are 1,2. If level&#x3D;1, then only 4 digits sic codes will be returned, level&#x3D;2 means only 8 digits sic codes will be returned. Multiple comma-separated values will also be accepted. So level&#x3D;&#39;1,2&#39; means return both 4 digits and 8 digits sic codes. (optional)
     * @return GeoEnrichMetadataResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeoEnrichMetadataResponse getSICMetadata(String sicCode, String level) throws ApiException {
        ApiResponse<GeoEnrichMetadataResponse> resp = getSICMetadataWithHttpInfo(sicCode, level);
        return resp.getData();
    }

    /**
     * Returns SIC Codes with their Industry Titles and Category Codes mapping
     * Accepts first few partial digits or full SIC codes to filter the response
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param level Allowed values are 1,2. If level&#x3D;1, then only 4 digits sic codes will be returned, level&#x3D;2 means only 8 digits sic codes will be returned. Multiple comma-separated values will also be accepted. So level&#x3D;&#39;1,2&#39; means return both 4 digits and 8 digits sic codes. (optional)
     * @return ApiResponse&lt;GeoEnrichMetadataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeoEnrichMetadataResponse> getSICMetadataWithHttpInfo(String sicCode, String level) throws ApiException {
        com.squareup.okhttp.Call call = getSICMetadataCall(sicCode, level, null, null);
        Type localVarReturnType = new TypeToken<GeoEnrichMetadataResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Returns SIC Codes with their Industry Titles and Category Codes mapping (asynchronously)
     * Accepts first few partial digits or full SIC codes to filter the response
     * @param sicCode Specify starting digits or full sic code to filter the response (optional)
     * @param level Allowed values are 1,2. If level&#x3D;1, then only 4 digits sic codes will be returned, level&#x3D;2 means only 8 digits sic codes will be returned. Multiple comma-separated values will also be accepted. So level&#x3D;&#39;1,2&#39; means return both 4 digits and 8 digits sic codes. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getSICMetadataAsync(String sicCode, String level, final ApiCallback<GeoEnrichMetadataResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getSICMetadataCall(sicCode, level, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeoEnrichMetadataResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for poisAutocomplete */
    private com.squareup.okhttp.Call poisAutocompleteCall(String longitude, String latitude, String searchText, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String country, String areaName1, String areaName3, String postcode1, String postcode2, String ipAddress, String autoDetectLocation, String type, String categoryCode, String sicCode, String maxCandidates, String sortBy, String searchOnNameOnly, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        

        // create path and map variables
        String localVarPath = "/geoenrich/v1/poi/autocomplete".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (searchText != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchText", searchText));
        if (searchRadius != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadius", searchRadius));
        if (searchRadiusUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchRadiusUnit", searchRadiusUnit));
        if (travelTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTime", travelTime));
        if (travelTimeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTimeUnit", travelTimeUnit));
        if (travelDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistance", travelDistance));
        if (travelDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistanceUnit", travelDistanceUnit));
        if (travelMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelMode", travelMode));
        if (country != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "country", country));
        if (areaName1 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "areaName1", areaName1));
        if (areaName3 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "areaName3", areaName3));
        if (postcode1 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "postcode1", postcode1));
        if (postcode2 != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "postcode2", postcode2));
        if (ipAddress != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "ipAddress", ipAddress));
        if (autoDetectLocation != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "autoDetectLocation", autoDetectLocation));
        if (type != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
        if (categoryCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "categoryCode", categoryCode));
        if (sicCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sicCode", sicCode));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (searchOnNameOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchOnNameOnly", searchOnNameOnly));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "application/xml"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Points of Interest Autocomplete.
     * POIs-Autocomplete will return POIs predictions based on the full or partial words specified in the search.The search can then be narrowed based on Location, IP Address or Country along with other supporting filters.
     * @param longitude Longitude of the location. (optional)
     * @param latitude Latitude of the location. (optional)
     * @param searchText Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking (optional)
     * @param country Country (optional)
     * @param areaName1 Specifies the largest geographical area, typically a state or province. (optional)
     * @param areaName3 Specifies the name of the city or town.  (optional)
     * @param postcode1 Postal Code of the input to be searched (optional)
     * @param postcode2 Postcode2 (optional)
     * @param ipAddress IP address of network connected device in standard IPv4 octet and a valid external address. (optional)
     * @param autoDetectLocation Specifies whether to auto-detect location from IP address. If &#39;True&#39; is set, the location is detected from the specified ip address. If &#39;False&#39; is set. the search will happen according to country or location. (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param sortBy Specifies the order in which POIs are retrieved. (optional, default to distance)
     * @param searchOnNameOnly specifies search on name (optional)
     * @return GeoEnrichResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GeoEnrichResponse poisAutocomplete(String longitude, String latitude, String searchText, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String country, String areaName1, String areaName3, String postcode1, String postcode2, String ipAddress, String autoDetectLocation, String type, String categoryCode, String sicCode, String maxCandidates, String sortBy, String searchOnNameOnly) throws ApiException {
        ApiResponse<GeoEnrichResponse> resp = poisAutocompleteWithHttpInfo(longitude, latitude, searchText, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, country, areaName1, areaName3, postcode1, postcode2, ipAddress, autoDetectLocation, type, categoryCode, sicCode, maxCandidates, sortBy, searchOnNameOnly);
        return resp.getData();
    }

    /**
     * Points of Interest Autocomplete.
     * POIs-Autocomplete will return POIs predictions based on the full or partial words specified in the search.The search can then be narrowed based on Location, IP Address or Country along with other supporting filters.
     * @param longitude Longitude of the location. (optional)
     * @param latitude Latitude of the location. (optional)
     * @param searchText Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking (optional)
     * @param country Country (optional)
     * @param areaName1 Specifies the largest geographical area, typically a state or province. (optional)
     * @param areaName3 Specifies the name of the city or town.  (optional)
     * @param postcode1 Postal Code of the input to be searched (optional)
     * @param postcode2 Postcode2 (optional)
     * @param ipAddress IP address of network connected device in standard IPv4 octet and a valid external address. (optional)
     * @param autoDetectLocation Specifies whether to auto-detect location from IP address. If &#39;True&#39; is set, the location is detected from the specified ip address. If &#39;False&#39; is set. the search will happen according to country or location. (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param sortBy Specifies the order in which POIs are retrieved. (optional, default to distance)
     * @param searchOnNameOnly specifies search on name (optional)
     * @return ApiResponse&lt;GeoEnrichResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GeoEnrichResponse> poisAutocompleteWithHttpInfo(String longitude, String latitude, String searchText, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String country, String areaName1, String areaName3, String postcode1, String postcode2, String ipAddress, String autoDetectLocation, String type, String categoryCode, String sicCode, String maxCandidates, String sortBy, String searchOnNameOnly) throws ApiException {
        com.squareup.okhttp.Call call = poisAutocompleteCall(longitude, latitude, searchText, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, country, areaName1, areaName3, postcode1, postcode2, ipAddress, autoDetectLocation, type, categoryCode, sicCode, maxCandidates, sortBy, searchOnNameOnly, null, null);
        Type localVarReturnType = new TypeToken<GeoEnrichResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Points of Interest Autocomplete. (asynchronously)
     * POIs-Autocomplete will return POIs predictions based on the full or partial words specified in the search.The search can then be narrowed based on Location, IP Address or Country along with other supporting filters.
     * @param longitude Longitude of the location. (optional)
     * @param latitude Latitude of the location. (optional)
     * @param searchText Matched against Name, BrandName and Trade Name. Partial terms are also matched with fuzziness (max edit distance is 1) (optional)
     * @param searchRadius Radius range within which search is performed. (optional)
     * @param searchRadiusUnit Radius unit such as Feet, Kilometers, Miles or Meters. (optional)
     * @param travelTime Specifies the travel time within which method searches for results (POIs which can be reached within travel time)the search boundary in terms of time mentioned in &#39;travelTimeUnit&#39;. The results are retrieved from the polygon formed based on the travel time specified. This means search can be done in the mentioned time results be from the mentioned time. (optional)
     * @param travelTimeUnit Specifies acceptable time units.Allowed values Minutes,Hours,Seconds and Milliseconds (optional)
     * @param travelDistance Specifies the search boundary in terms of distance mentioned in &#39;travelDistanceUnit&#39;. The results are retrieved from the polygon formed based on the travel distance specified. (optional)
     * @param travelDistanceUnit Specifies acceptable time units.Allowed values Feet,Kilometers,Miles and Meters (optional)
     * @param travelMode Specifies the available mode of commute. This is required when u r trying to do search by travel distance or travel time. Allowed values driving and walking (optional)
     * @param country Country (optional)
     * @param areaName1 Specifies the largest geographical area, typically a state or province. (optional)
     * @param areaName3 Specifies the name of the city or town.  (optional)
     * @param postcode1 Postal Code of the input to be searched (optional)
     * @param postcode2 Postcode2 (optional)
     * @param ipAddress IP address of network connected device in standard IPv4 octet and a valid external address. (optional)
     * @param autoDetectLocation Specifies whether to auto-detect location from IP address. If &#39;True&#39; is set, the location is detected from the specified ip address. If &#39;False&#39; is set. the search will happen according to country or location. (optional)
     * @param type Matched against the content which defines the type of the poi.  (optional)
     * @param categoryCode Specific Category/Categories Codes for the desired POIs. Accepts a mix of 4 digit (Top Category), 6 digit (Second-Level Category) and 11 digit (Low-Level Category) Category Codes. https://locate.pitneybowes.com/downloads/location-intelligence/v1/CategoryCodes.xlsx  (optional)
     * @param sicCode Specific SIC Codes/Codes for the desired POIs. Accepts a mix of 4 digit (Top Category) and 8 digit (Low-Level Category) SIC Codes. (optional)
     * @param maxCandidates Maximum number of POIs that can be retrieved. (optional)
     * @param sortBy Specifies the order in which POIs are retrieved. (optional, default to distance)
     * @param searchOnNameOnly specifies search on name (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call poisAutocompleteAsync(String longitude, String latitude, String searchText, String searchRadius, String searchRadiusUnit, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String travelMode, String country, String areaName1, String areaName3, String postcode1, String postcode2, String ipAddress, String autoDetectLocation, String type, String categoryCode, String sicCode, String maxCandidates, String sortBy, String searchOnNameOnly, final ApiCallback<GeoEnrichResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = poisAutocompleteCall(longitude, latitude, searchText, searchRadius, searchRadiusUnit, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, travelMode, country, areaName1, areaName3, postcode1, postcode2, ipAddress, autoDetectLocation, type, categoryCode, sicCode, maxCandidates, sortBy, searchOnNameOnly, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GeoEnrichResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
